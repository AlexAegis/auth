{"version":3,"file":"jwt-refresh.interceptor.js","sourceRoot":"","sources":["../../../../../../libs/jwt/src/lib/interceptor/jwt-refresh.interceptor.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n\tHttpErrorResponse,\n\tHttpEvent,\n\tHttpHandler,\n\tHttpInterceptor,\n\tHttpRequest,\n} from '@angular/common/http';\nimport { Inject, Injectable } from '@angular/core';\nimport { Observable, throwError } from 'rxjs';\nimport { catchError, filter, switchMap, take, withLatestFrom } from 'rxjs/operators';\nimport { JwtCannotRefreshError, JwtCouldntRefreshError, JwtError } from '../errors/jwt-error.class';\nimport { checkAgainstUrlFilter } from '../function/check-against-url-filter.function';\nimport { intoObservable } from '../function/into-observable.function';\nimport { matchAgainst } from '../function/match-against.function';\nimport { separateUrl } from '../function/separate-url.function';\nimport { tryJwtRefresh } from '../function/try-jwt-refresh.function';\nimport {\n\tJwtConfiguration,\n\tJwtRefreshConfiguration,\n} from '../model/auth-core-configuration.interface';\nimport { JwtToken } from '../model/jwt-token.class';\nimport { JwtRefreshStateService } from '../service/jwt-refresh-state.service';\nimport { JwtTokenService } from '../service/jwt-token.service';\nimport {\n\tDEFAULT_JWT_CONFIGURATION_TOKEN,\n\tDEFAULT_JWT_REFRESH_CONFIGURATION_TOKEN,\n\tJWT_CONFIGURATION_TOKEN,\n\tJWT_REFRESH_CONFIGURATION_TOKEN,\n} from '../token/jwt-configuration.token';\n\n@Injectable()\nexport class JwtRefreshInterceptor implements HttpInterceptor {\n\tprivate readonly jwtConfiguration!: JwtConfiguration;\n\tprivate readonly jwtRefreshConfiguration!: JwtRefreshConfiguration<unknown, unknown>;\n\tprivate readonly rawRefreshToken$: Observable<string | null | undefined>;\n\tprivate readonly isRawRefreshTokenGetterAvailable: boolean;\n\n\tpublic constructor(\n\t\t@Inject(JWT_CONFIGURATION_TOKEN)\n\t\treadonly jwtConfig: JwtConfiguration,\n\t\t@Inject(DEFAULT_JWT_CONFIGURATION_TOKEN)\n\t\treadonly defaultJwtConfig: JwtConfiguration,\n\t\t@Inject(JWT_REFRESH_CONFIGURATION_TOKEN)\n\t\treadonly refreshConfig: JwtRefreshConfiguration<unknown, unknown>,\n\t\t@Inject(DEFAULT_JWT_REFRESH_CONFIGURATION_TOKEN)\n\t\treadonly defaultJwtRefreshConfig: JwtRefreshConfiguration<unknown, unknown>,\n\t\tprivate readonly jwtRefreshStateService: JwtRefreshStateService,\n\t\tprivate readonly jwtTokenService: JwtTokenService\n\t) {\n\t\tthis.jwtConfiguration = {\n\t\t\t...defaultJwtConfig,\n\t\t\t...jwtConfig,\n\t\t};\n\n\t\tthis.jwtRefreshConfiguration = {\n\t\t\t...defaultJwtRefreshConfig,\n\t\t\t...refreshConfig,\n\t\t};\n\n\t\tthis.rawRefreshToken$ = intoObservable(\n\t\t\tthis.jwtRefreshConfiguration.getRefreshToken ?? (() => null)\n\t\t);\n\n\t\tthis.isRawRefreshTokenGetterAvailable = !!this.jwtRefreshConfiguration.getRefreshToken;\n\t}\n\n\tprivate handleWithToken(\n\t\trequest: HttpRequest<unknown>,\n\t\tnext: HttpHandler,\n\t\ttoken: string\n\t): Observable<HttpEvent<unknown>> {\n\t\tconst requestWithUpdatedTokens = request.clone({\n\t\t\theaders: request.headers.set(\n\t\t\t\tthis.jwtConfiguration.header,\n\t\t\t\tthis.jwtConfiguration.scheme + token\n\t\t\t),\n\t\t});\n\t\treturn next.handle(requestWithUpdatedTokens);\n\t}\n\n\tpublic intercept(\n\t\trequest: HttpRequest<unknown>,\n\t\tnext: HttpHandler\n\t): Observable<HttpEvent<unknown>> {\n\t\tconst separatedUrl = separateUrl(request.url);\n\t\tconst jwtHeaderValue = request.headers.get(this.jwtConfiguration.header);\n\n\t\t// Only do something if the request is headed towards a protected endpoint.\n\t\t// The forRoot method of the module ensures that this interceptor is injected\n\t\t// after the token injector interceptor. So by the time this executes, the token should\n\t\t// be here.\n\t\t// And if the url is not the refresh url itself, and any of the other explicitly\n\t\t// filtered urls where refresh is prohibited by config.\n\t\tif (\n\t\t\tjwtHeaderValue &&\n\t\t\t!matchAgainst(request.url)(this.jwtRefreshConfiguration.refreshUrl) &&\n\t\t\tcheckAgainstUrlFilter(this.jwtRefreshConfiguration, separatedUrl)\n\t\t) {\n\t\t\t// If locked, instead of refreshing, wait for it and get the new accessToken\n\t\t\tif (this.jwtRefreshStateService.refreshLock$.value) {\n\t\t\t\t// When the lock unlocks, retry with the new token\n\t\t\t\treturn this.jwtRefreshStateService.refreshLock$.pipe(\n\t\t\t\t\tfilter((lock) => !lock),\n\t\t\t\t\ttake(1),\n\t\t\t\t\twithLatestFrom(this.jwtTokenService.rawAccessToken$),\n\t\t\t\t\tswitchMap(([, accessToken]) => {\n\t\t\t\t\t\t// ...but only if there is actually a token\n\t\t\t\t\t\tif (accessToken) {\n\t\t\t\t\t\t\treturn this.handleWithToken(request, next, accessToken);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn throwError(\n\t\t\t\t\t\t\t\tJwtError.createErrorResponse(\n\t\t\t\t\t\t\t\t\trequest,\n\t\t\t\t\t\t\t\t\t'No access token available after waiting for a refresh'\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t);\n\t\t\t}\n\n\t\t\treturn this.rawRefreshToken$.pipe(\n\t\t\t\ttake(1),\n\t\t\t\tswitchMap((rawRefreshToken) => {\n\t\t\t\t\tconst rawToken = JwtToken.stripScheme(\n\t\t\t\t\t\tjwtHeaderValue,\n\t\t\t\t\t\tthis.jwtConfiguration.scheme\n\t\t\t\t\t);\n\t\t\t\t\tconst token = JwtToken.from(rawToken);\n\t\t\t\t\tconst refreshToken = rawRefreshToken ? JwtToken.from(rawRefreshToken) : null;\n\t\t\t\t\tconst isAccessTokenExpiredOrInvalid = !token || token.isExpired();\n\t\t\t\t\tconst isRefreshTokenExpiredOrInvalid =\n\t\t\t\t\t\t!refreshToken || refreshToken.isExpired();\n\t\t\t\t\t// If we know beforehand that nothing can be done, panic.\n\t\t\t\t\tif (\n\t\t\t\t\t\tisAccessTokenExpiredOrInvalid &&\n\t\t\t\t\t\tthis.isRawRefreshTokenGetterAvailable &&\n\t\t\t\t\t\tisRefreshTokenExpiredOrInvalid\n\t\t\t\t\t) {\n\t\t\t\t\t\treturn throwError(\n\t\t\t\t\t\t\tJwtCannotRefreshError.createErrorResponse(\n\t\t\t\t\t\t\t\trequest,\n\t\t\t\t\t\t\t\t'Both access and refresh tokens are expired'\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\t// If the conversion would fail, that would handle the same as an expired token\n\t\t\t\t\treturn (\n\t\t\t\t\t\tisAccessTokenExpiredOrInvalid\n\t\t\t\t\t\t\t? // If the token is used and is expired, don't even try the request.\n\t\t\t\t\t\t\t  throwError('Expired token, refresh first')\n\t\t\t\t\t\t\t: // If it seems okay, try the request\n\t\t\t\t\t\t\t  next.handle(request)\n\t\t\t\t\t).pipe(\n\t\t\t\t\t\tcatchError((error: HttpErrorResponse | string) =>\n\t\t\t\t\t\t\t// If the request failed, or we failed at the precheck\n\t\t\t\t\t\t\t// Acquire a new token, but only if the error is allowing it\n\t\t\t\t\t\t\t// If a refresh is already happening, wait for it, and use it's results\n\t\t\t\t\t\t\ttryJwtRefresh(\n\t\t\t\t\t\t\t\tnext,\n\t\t\t\t\t\t\t\terror,\n\t\t\t\t\t\t\t\tthis.jwtRefreshConfiguration,\n\t\t\t\t\t\t\t\tthis.jwtRefreshStateService.refreshLock$,\n\t\t\t\t\t\t\t\t(refreshError) =>\n\t\t\t\t\t\t\t\t\tthrowError(\n\t\t\t\t\t\t\t\t\t\tJwtCouldntRefreshError.createErrorResponse(\n\t\t\t\t\t\t\t\t\t\t\trequest,\n\t\t\t\t\t\t\t\t\t\t\trefreshError\n\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\t(refreshResponse) =>\n\t\t\t\t\t\t\t\t\tthis.handleWithToken(request, next, refreshResponse.accessToken)\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t)\n\t\t\t\t\t);\n\t\t\t\t})\n\t\t\t);\n\t\t} else {\n\t\t\treturn next.handle(request);\n\t\t}\n\t}\n}\n"]}