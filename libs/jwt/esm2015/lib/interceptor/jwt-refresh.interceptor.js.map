{"version":3,"file":"jwt-refresh.interceptor.js","sourceRoot":"../../../../libs/jwt/src/","sources":["lib/interceptor/jwt-refresh.interceptor.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n\tHttpErrorResponse,\n\tHttpEvent,\n\tHttpHandler,\n\tHttpInterceptor,\n\tHttpRequest,\n} from '@angular/common/http';\nimport { Inject, Injectable } from '@angular/core';\nimport { Observable, throwError } from 'rxjs';\nimport { catchError, switchMap, take } from 'rxjs/operators';\nimport { JwtCannotRefreshError, JwtCouldntRefreshError } from '../errors/jwt-error.class';\nimport { checkAgainstUrlFilter } from '../function/check-against-url-filter.function';\nimport { intoObservable } from '../function/into-observable.function';\nimport { matchAgainst } from '../function/match-against.function';\nimport { separateUrl } from '../function/separate-url.function';\nimport { tryJwtRefresh } from '../function/try-jwt-refresh.function';\nimport {\n\tJwtConfiguration,\n\tJwtRefreshConfiguration,\n} from '../model/auth-core-configuration.interface';\nimport { JwtToken } from '../model/jwt-token.class';\nimport {\n\tDEFAULT_JWT_CONFIGURATION_TOKEN,\n\tDEFAULT_JWT_REFRESH_CONFIGURATION_TOKEN,\n\tJWT_CONFIGURATION_TOKEN,\n\tJWT_REFRESH_CONFIGURATION_TOKEN,\n} from '../token/jwt-configuration.token';\n\n@Injectable()\nexport class JwtRefreshInterceptor implements HttpInterceptor {\n\tprivate readonly jwtConfiguration!: JwtConfiguration;\n\tprivate readonly jwtRefreshConfiguration!: JwtRefreshConfiguration<unknown, unknown>;\n\tprivate readonly rawRefreshToken$: Observable<string | null | undefined>;\n\tprivate readonly isRawRefreshTokenGetterAvailable: boolean;\n\n\tpublic constructor(\n\t\t@Inject(JWT_CONFIGURATION_TOKEN)\n\t\tjwtConfig: JwtConfiguration,\n\t\t@Inject(DEFAULT_JWT_CONFIGURATION_TOKEN)\n\t\tdefaultJwtConfig: JwtConfiguration,\n\t\t@Inject(JWT_REFRESH_CONFIGURATION_TOKEN)\n\t\trefreshConfig: JwtRefreshConfiguration<unknown, unknown>,\n\t\t@Inject(DEFAULT_JWT_REFRESH_CONFIGURATION_TOKEN)\n\t\tdefaultJwtRefreshConfig: JwtRefreshConfiguration<unknown, unknown>\n\t) {\n\t\tthis.jwtConfiguration = {\n\t\t\t...defaultJwtConfig,\n\t\t\t...jwtConfig,\n\t\t};\n\n\t\tthis.jwtRefreshConfiguration = {\n\t\t\t...defaultJwtRefreshConfig,\n\t\t\t...refreshConfig,\n\t\t};\n\n\t\tthis.rawRefreshToken$ = intoObservable(\n\t\t\tthis.jwtRefreshConfiguration.getRefreshToken ?? (() => null)\n\t\t);\n\n\t\tthis.isRawRefreshTokenGetterAvailable = !!this.jwtRefreshConfiguration.getRefreshToken;\n\t}\n\n\tpublic intercept(\n\t\trequest: HttpRequest<unknown>,\n\t\tnext: HttpHandler\n\t): Observable<HttpEvent<unknown>> {\n\t\tconst separatedUrl = separateUrl(request.url);\n\t\tconst jwtHeaderValue = request.headers.get(this.jwtConfiguration.header);\n\n\t\t// Only do something if the request is headed towards a protected endpoint.\n\t\t// The forRoot method of the module ensures that this interceptor is injected\n\t\t// after the token injector interceptor. So by the time this executes, the token should\n\t\t// be here.\n\t\t// And if the url is not the refresh url itself, and any of the other explicitly\n\t\t// filtered urls where refresh is prohibited by config.\n\t\tif (\n\t\t\tjwtHeaderValue &&\n\t\t\t!matchAgainst(request.url)(this.jwtRefreshConfiguration.refreshUrl) &&\n\t\t\tcheckAgainstUrlFilter(this.jwtRefreshConfiguration, separatedUrl)\n\t\t) {\n\t\t\treturn this.rawRefreshToken$.pipe(\n\t\t\t\ttake(1),\n\t\t\t\tswitchMap((rawRefreshToken) => {\n\t\t\t\t\tconst rawToken = JwtToken.stripScheme(\n\t\t\t\t\t\tjwtHeaderValue,\n\t\t\t\t\t\tthis.jwtConfiguration.scheme\n\t\t\t\t\t);\n\t\t\t\t\tconst token = JwtToken.from(rawToken);\n\t\t\t\t\tconst refreshToken = rawRefreshToken ? JwtToken.from(rawRefreshToken) : null;\n\t\t\t\t\tconst isAccessTokenExpiredOrInvalid = !token || token.isExpired();\n\t\t\t\t\tconst isRefreshTokenExpiredOrInvalid =\n\t\t\t\t\t\t!refreshToken || refreshToken.isExpired();\n\t\t\t\t\t// If we know beforehand that nothing can be done, panic.\n\t\t\t\t\tif (\n\t\t\t\t\t\tisAccessTokenExpiredOrInvalid &&\n\t\t\t\t\t\tthis.isRawRefreshTokenGetterAvailable &&\n\t\t\t\t\t\tisRefreshTokenExpiredOrInvalid\n\t\t\t\t\t) {\n\t\t\t\t\t\treturn throwError(\n\t\t\t\t\t\t\tJwtCannotRefreshError.createErrorResponse(\n\t\t\t\t\t\t\t\trequest,\n\t\t\t\t\t\t\t\t'Both access and refresh tokens are expired'\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\t// If the conversion would fail, that would handle the same as an expired token\n\t\t\t\t\treturn (isAccessTokenExpiredOrInvalid\n\t\t\t\t\t\t? // If the token is used and is expired, don't even try the request.\n\t\t\t\t\t\t  throwError('Expired token, refresh first')\n\t\t\t\t\t\t: // If it seems okay, try the request\n\t\t\t\t\t\t  next.handle(request)\n\t\t\t\t\t).pipe(\n\t\t\t\t\t\tcatchError((error: HttpErrorResponse | string) =>\n\t\t\t\t\t\t\t// If the request failed, or we failed at the precheck\n\t\t\t\t\t\t\t// Acquire a new token, but only if the error is allowing it\n\n\t\t\t\t\t\t\ttryJwtRefresh(\n\t\t\t\t\t\t\t\tnext,\n\t\t\t\t\t\t\t\terror,\n\t\t\t\t\t\t\t\tthis.jwtRefreshConfiguration,\n\t\t\t\t\t\t\t\t(refreshError) =>\n\t\t\t\t\t\t\t\t\tthrowError(\n\t\t\t\t\t\t\t\t\t\tJwtCouldntRefreshError.createErrorResponse(\n\t\t\t\t\t\t\t\t\t\t\trequest,\n\t\t\t\t\t\t\t\t\t\t\trefreshError\n\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\t(refreshResponse) => {\n\t\t\t\t\t\t\t\t\tconst requestWithUpdatedTokens = request.clone({\n\t\t\t\t\t\t\t\t\t\theaders: request.headers.set(\n\t\t\t\t\t\t\t\t\t\t\tthis.jwtConfiguration.header,\n\t\t\t\t\t\t\t\t\t\t\tthis.jwtConfiguration.scheme +\n\t\t\t\t\t\t\t\t\t\t\t\trefreshResponse.accessToken\n\t\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\treturn next.handle(requestWithUpdatedTokens);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t)\n\t\t\t\t\t);\n\t\t\t\t})\n\t\t\t);\n\t\t} else {\n\t\t\treturn next.handle(request);\n\t\t}\n\t}\n}\n"]}