{"version":3,"file":"jwt-token.class.js","sourceRoot":"/home/runner/work/auth/auth/libs/jwt/src/","sources":["lib/model/jwt-token.class.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,MAAM,EAAE,MAAM,WAAW,CAAC;AACnC,OAAO,EAAgB,oBAAoB,EAAE,MAAM,qCAAqC,CAAC;AACzF,OAAO,EAAE,sBAAsB,EAAE,MAAM,gDAAgD,CAAC;AAkExF,MAAM,OAAO,QAAQ;IACpB,YACQ,MAAsB,EACtB,OAAiC,EACjC,SAAiB;QAFjB,WAAM,GAAN,MAAM,CAAgB;QACtB,YAAO,GAAP,OAAO,CAA0B;QACjC,cAAS,GAAT,SAAS,CAAQ;IACtB,CAAC;IAGG,MAAM,CAAC,IAAI,CACjB,KAAqB;QAErB,MAAM,iBAAiB,GAAG,QAAQ,CAAC,gBAAgB,CAAC,KAAK,CAAC,CAAC;QAC3D,IAAI,CAAC,iBAAiB;YAAE,OAAO,IAAI,CAAC;QAEpC,MAAM,MAAM,GAAG,oBAAoB,CAAiB,iBAAiB,CAAC,CAAC,CAAC,CAAC,CAAC;QAC1E,MAAM,OAAO,GAAG,oBAAoB,CAA2B,iBAAiB,CAAC,CAAC,CAAC,CAAC,CAAC;QACrF,MAAM,SAAS,GAAG,MAAM,CAAC,MAAM,CAAC,iBAAiB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,gCAAgC;QACvF,IAAI,CAAC,MAAM,IAAI,CAAC,OAAO,IAAI,CAAC,SAAS;YAAE,OAAO,IAAI,CAAC;QAEnD,OAAO,IAAI,QAAQ,CAAS,MAAM,EAAE,OAAO,EAAE,SAAS,CAAC,CAAC;IACzD,CAAC;IAEM,MAAM,CAAC,WAAW,CAAC,cAAsB,EAAE,MAAe;QAChE,OAAO,cAAc,CAAC,SAAS,CAAC,CAAC,MAAM,aAAN,MAAM,cAAN,MAAM,GAAI,EAAE,CAAC,CAAC,MAAM,CAAC,CAAC;IACxD,CAAC;IAEM,MAAM,CAAC,gBAAgB,CAC7B,KAAqB,EACrB,YAAoB,QAAQ,CAAC,mBAAmB;QAEhD,MAAM,GAAG,GAAG,KAAK,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC;QACnC,IAAI,GAAG,CAAC,MAAM,KAAK,CAAC,EAAE;YACrB,OAAO,IAAI,CAAC;SACZ;QACD,OAAO,GAAiD,CAAC;IAC1D,CAAC;IAEM,SAAS;QACf,OAAO,sBAAsB,CAAC,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC;IACjD,CAAC;;AAjCa,4BAAmB,GAAG,GAAG,CAAC","sourcesContent":["import { Base64 } from 'js-base64';\nimport { Base64String, decodeJsonLikeBase64 } from '../function/base64-decoder.function';\nimport { isUnixTimestampExpired } from '../function/is-unix-timestamp-expired.function';\n\nexport type JwtTokenString = string;\nexport type UnixTime = number;\n\nexport interface JwtTokenHeader {\n\t/**\n\t * Media type\n\t */\n\ttyp?: string;\n\t/**\n\t * Content Type\n\t */\n\tcty?: 'JWT' | string;\n\t/**\n\t * Algorithm\n\t */\n\talg: string;\n\t/**\n\t * Encryption\n\t */\n\tenc?: string;\n}\n\n/**\n * Registered claim names defined in RFC 7519 are predefined here.\n */\nexport interface JwtTokenPayload {\n\t/**\n\t * Issuer\n\t */\n\tiss?: string;\n\t/**\n\t * Subject\n\t */\n\tsub?: string;\n\t/**\n\t * Audience\n\t */\n\taud?: string;\n\t/**\n\t * Expiration Time\n\t */\n\texp: UnixTime;\n\t/**\n\t * Not Before\n\t */\n\tnbf?: UnixTime;\n\t/**\n\t * Issued at\n\t */\n\tiat?: UnixTime;\n\t/**\n\t * JWT ID\n\t */\n\tjti?: string;\n}\n\n/**\n * Common token pair\n */\nexport interface JwtTokenPair {\n\taccessToken: JwtTokenString;\n\trefreshToken: JwtTokenString;\n}\n\nexport class JwtToken<Claims = Record<string | number, unknown>> {\n\tpublic constructor(\n\t\tpublic header: JwtTokenHeader,\n\t\tpublic payload: JwtTokenPayload & Claims,\n\t\tpublic signature: string\n\t) {}\n\tpublic static JWT_TOKEN_SEPARATOR = '.';\n\n\tpublic static from<Claims = Record<string | number, unknown>>(\n\t\ttoken: JwtTokenString\n\t): JwtToken<Claims> | null {\n\t\tconst convertedSegments = JwtToken.splitTokenString(token);\n\t\tif (!convertedSegments) return null;\n\n\t\tconst header = decodeJsonLikeBase64<JwtTokenHeader>(convertedSegments[0]);\n\t\tconst payload = decodeJsonLikeBase64<JwtTokenPayload & Claims>(convertedSegments[1]);\n\t\tconst signature = Base64.decode(convertedSegments[2]); // Not used, only for validation\n\t\tif (!header || !payload || !signature) return null;\n\n\t\treturn new JwtToken<Claims>(header, payload, signature);\n\t}\n\n\tpublic static stripScheme(jwtHeaderValue: string, scheme?: string): JwtTokenString {\n\t\treturn jwtHeaderValue.substring((scheme ?? '').length);\n\t}\n\n\tpublic static splitTokenString(\n\t\ttoken: JwtTokenString,\n\t\tseparator: string = JwtToken.JWT_TOKEN_SEPARATOR\n\t): [Base64String, Base64String, Base64String] | null {\n\t\tconst spl = token.split(separator);\n\t\tif (spl.length !== 3) {\n\t\t\treturn null;\n\t\t}\n\t\treturn spl as [Base64String, Base64String, Base64String];\n\t}\n\n\tpublic isExpired(): boolean {\n\t\treturn isUnixTimestampExpired(this.payload.exp);\n\t}\n}\n"]}