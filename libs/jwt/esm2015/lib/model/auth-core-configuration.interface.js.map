{"version":3,"file":"auth-core-configuration.interface.js","sourceRoot":"/home/runner/work/auth/auth/libs/jwt/src/","sources":["lib/model/auth-core-configuration.interface.ts"],"names":[],"mappings":"AAIA,OAAO,EACN,qBAAqB,GAGrB,MAAM,yCAAyC,CAAC;AAGjD,MAAM,CAAC,MAAM,kBAAkB,GAAG,eAAe,CAAC;AAClD,MAAM,CAAC,MAAM,kBAAkB,GAAG,SAAS,CAAC;AAE5C,MAAM,CAAC,MAAM,kBAAkB,mCAC3B,qBAAqB,KACxB,MAAM,EAAE,kBAAkB,EAC1B,MAAM,EAAE,kBAAkB,EAC1B,qBAAqB,EAAE,IAAI,GAC3B,CAAC;AAEF,MAAM,CAAC,MAAM,gDAAgD,GAAG,IAAI,CAAC;AAErE,MAAM,CAAC,MAAM,0BAA0B,GAAuD;IAC7F,MAAM,EAAE,MAAM;IACd,kBAAkB,EAAE,CAAC,GAAG,CAAC;IACzB,yCAAyC,EAAE,gDAAgD;CAC3F,CAAC","sourcesContent":["import { HttpHeaders, HttpParams } from '@angular/common/http';\nimport { Params } from '@angular/router';\nimport { Observable } from 'rxjs';\nimport { JwtCannotRefreshError, JwtCouldntRefreshError, JwtError } from '../errors/jwt-error.class';\nimport {\n\tDEFAULT_HEADER_CONFIG,\n\tHeaderConfiguration,\n\tUrlFilter,\n} from '../model/header-configuration.interface';\nimport { HttpMethodType } from './http-method.enum';\n\nexport const DEFAULT_JWT_HEADER = 'Authorization';\nexport const DEFAULT_JWT_SCHEME = 'Bearer ';\n\nexport const DEFAULT_JWT_CONFIG: Partial<JwtConfiguration> = {\n\t...DEFAULT_HEADER_CONFIG,\n\theader: DEFAULT_JWT_HEADER,\n\tscheme: DEFAULT_JWT_SCHEME,\n\thandleWithCredentials: true,\n};\n\nexport const DEFAULT_JWT_REFRESH_CONFIG_DEFAULT_AUTO_IN_GUARD = true;\n\nexport const DEFAULT_JWT_REFRESH_CONFIG: Partial<JwtRefreshConfiguration<unknown, unknown>> = {\n\tmethod: 'POST',\n\terrorCodeWhitelist: [401],\n\tisAutoRefreshAllowedInLoginGuardByDefault: DEFAULT_JWT_REFRESH_CONFIG_DEFAULT_AUTO_IN_GUARD,\n};\n\nexport interface JwtRefreshResponse {\n\taccessToken: string;\n\trefreshToken?: string;\n}\n\nexport interface HttpRequestInit {\n\theaders?: HttpHeaders;\n\treportProgress?: boolean;\n\tparams?: HttpParams;\n\tresponseType?: 'arraybuffer' | 'blob' | 'json' | 'text';\n\twithCredentials?: boolean;\n}\n\n/**\n * TODO: optional generic matcher function\n */\nexport interface HttpErrorFilter {\n\t/**\n\t * The error codes on which an act is allowed to happen,\n\t * an empty array means it can't act on anything\n\t *\n\t * @default [401]\n\t */\n\terrorCodeWhitelist?: number[];\n\n\t/**\n\t * The error codes on which an act is not allowed to happen,\n\t * an empty array (and if undefined) means it can always try a single\n\t * act in case of an error\n\t *\n\t * @default undefined\n\t */\n\terrorCodeBlacklist?: number[];\n}\n\n/**\n * Enables the RefreshInterceptor which will automatically tries to\n * refresh the accessToken on expiration or failure of the next request.\n *\n * Because handling refreshes is not standardized, instead of asking for the\n * refresh token directly I ask you to provide the request itself, however you\n * like to. In these callbacks you can access your refreshToken wherever you\n * store it.\n *\n * You can still configure a `getRefreshToken` property but it's optional,\n * not used in the interceptor at all, and is only used in the helper service.\n * If you do not with to interact with the parsed refreshToken (Usually you\n * don't need to) you can leave that out. But it's there if you might need it.\n *\n * The reason it's configured through multiple properties instead of a callback\n * where I let you do the refresh request however you see fit is to make sure the\n * refreshUrl is known to avoid potentional infinite requests when hitting the\n * refresh endpoint. This way you don't have to remember setting this into the\n * url filter manually.\n *\n * @example configuration.\n * AuthCoreModule.forRoot<TokenStorageService>({\n *\t\tuseFactory: (service: TokenStorageService) => ({\n *\t\t\tgetToken: service.accessToken$\n *\t\t\tautoRefresher: {\n * \t\t\t\tendpoint: `${environment.api}/auth/refresh`,\n * \t\t\t\tsetToken: (response) => service.accessToken$.next(response.accessToken)\n * \t\t\t}\n *\t\t}),\n *\t\tdeps: [TokenStorageService],\n * })\n *\n * @default undefined\n */\nexport interface JwtRefreshConfiguration<RefreshRequest, RefreshResponse>\n\textends UrlFilter,\n\t\tHttpErrorFilter {\n\t/**\n\t * After a successful refresh, this callback will be called.\n\t * You need to define a function which will save the the token in a way\n\t * that if the interceptor calls `getToken` again, it will get the token\n\t * saved with this method.\n\t *\n\t * @example using `localStorage`\n\t * \t\tsetToken: (response) => localStorage.setItem('accessToken', response.accessToken)\n\t * @example using a service.\n\t *\n\t * ```typescript\n\t * AuthCoreModule.forRoot<TokenStorageService>({\n\t *\t\tuseFactory: (service: TokenStorageService) => ({\n\t *\t\t\tgetToken: service.accessToken$\n\t *\t\t\tautoRefresher: {\n\t * \t\t\t\tendpoint: `${environment.api}/auth/refresh`,\n\t * \t\t\t\tsetRefreshToken: (response) => service.accessToken$.next(response.accessToken)\n\t * \t\t\t}\n\t *\t\t}),\n\t *\t\tdeps: [TokenStorageService],\n\t * })\n\t * ```\n\t *\n\t */\n\tsetRefreshedTokens: (response: JwtRefreshResponse) => void;\n\n\t/**\n\t * The method for the request, usually it's a POST so that's the default\n\t *\n\t * @default 'POST'\n\t */\n\tmethod?: HttpMethodType;\n\n\t/**\n\t * The endpoint that will be requested for a new token\n\t */\n\trefreshUrl: string;\n\n\t/**\n\t * A callback or observable that can be used to retrieve the body of the\n\t * request. If it's null or undefined, the refresh won't be executed. This\n\t * can be utilized to not do a refresh on a logged out state.\n\t *\n\t * @example getValue: () => localstorage.get('foo')\n\t * @example getValue: myTokenService.foo$\n\t */\n\tcreateRefreshRequestBody:\n\t\t| Observable<RefreshRequest | null | undefined>\n\t\t| (() =>\n\t\t\t\t| RefreshRequest\n\t\t\t\t| null\n\t\t\t\t| undefined\n\t\t\t\t| Promise<RefreshRequest | null | undefined>\n\t\t\t\t| Observable<RefreshRequest | null | undefined>);\n\n\t/**\n\t * A callback that should return the defaults on the request\n\t */\n\trefreshRequestInitials?: (() => HttpRequestInit | undefined) | HttpRequestInit;\n\n\t/**\n\t * This function have to transform the result of your refresh endpoint\n\t * into a digestable form. It will be called after successful refreshes.\n\t */\n\ttransformRefreshResponse: (response: RefreshResponse) => JwtRefreshResponse;\n\n\t/**\n\t * This callback is called when a refresh either failed or cannot be done.\n\t * This marks the point where both tokens are invalid and the user needs to\n\t * relog. Because this is usually done through a login page, aside from a\n\t * regular callback, a string can also be supplied which will act as the\n\t * target of navigation. Check `onFailureRedirectParameters` if you wish\n\t * to supply query parameters. For more advanced usage, consider\n\t * implementing it as a custom function, the error object is available\n\t * there too!\n\t */\n\tonFailure?: string | ((error: JwtCouldntRefreshError | JwtCannotRefreshError) => void);\n\n\tonFailureRedirectParameters?:\n\t\t| ((error: JwtCouldntRefreshError | JwtCannotRefreshError) => HttpParams | Params)\n\t\t| HttpParams\n\t\t| Params;\n\n\t/**\n\t * Optional!\n\t *\n\t * The refresh mechanic only uses this to determine if it's expired or not\n\t * and so potentionally saving a request that would fail anyway. It is\n\t * also used in the helper service if you with to interact with the\n\t * parsed refreshToken throught the helper observables. If you do not\n\t * need either of these, you don't have to implement this.\n\t *\n\t * A callback or observable that can be used to retrieve the refresh token\n\t * Not used in the interceptor!\n\t *\n\t * @example getValue: () => localstorage.get('foo')\n\t * @example getValue: myTokenService.foo$\n\t */\n\tgetRefreshToken?:\n\t\t| Observable<string | null | undefined>\n\t\t| (() =>\n\t\t\t\t| string\n\t\t\t\t| null\n\t\t\t\t| undefined\n\t\t\t\t| Promise<string | null | undefined>\n\t\t\t\t| Observable<string | null | undefined>);\n\n\t/**\n\t * When using the LoginGuard this setting will determine the default\n\t * value. So instead of disabling the autoRefresh behavior on every\n\t * route with the data option, or writing your own guard (Which would\n\t * be really simple) just set this to false. You can still override it\n\t * using route data.\n\t *\n\t * See the LoginGuardData helper interface to see what it can utilize.\n\t *\n\t * @default true\n\t */\n\tisAutoRefreshAllowedInLoginGuardByDefault?: boolean;\n}\n\n/**\n * This is a helper interface because they look the same on both\n * `JwtConfiguration` and `JwtRefreshConfiguration`. They are re-defined\n * on them to provide better documentation.\n *\n * In the case where you wish to implement them both in a separate object\n * then spread it back to both to reduce code-duplication, this type can\n * be utilized.\n */\nexport interface JwtErrorHandling {\n\t/**\n\t * If it's a string, instead of calling it, a redirection will happen,\n\t * with `onFailureRedirectParameters` as it's queryParams.\n\t */\n\tonFailure?:\n\t\t| string\n\t\t| ((jwtError: JwtError | JwtCouldntRefreshError | JwtCannotRefreshError) => void);\n\n\t/**\n\t * This option is only used when the `onFailure` option is a string\n\t * so it's handled as a redirect. When this happens, you can define\n\t * the queryparams to be used with this redirect.\n\t *\n\t * When implemented as a function, the JwtError will be forwarded to it.\n\t * All JwtErrors have the `originalRequest` available in them, so it's\n\t * trivial to acquire the failed url.\n\t */\n\tonFailureRedirectParameters?:\n\t\t| ((\n\t\t\t\terror: JwtError | JwtCouldntRefreshError | JwtCannotRefreshError\n\t\t  ) => HttpParams | Params)\n\t\t| HttpParams\n\t\t| Params;\n}\n\n/**\n * Token injection configuration\n *\n * The optional generic defined the refresh endpoints Response type. If you\n * are not using that feature there's no need to define it.\n *\n * Example configuration:\n * ```typescript\n * AuthCoreModule.forRoot<TokenStorageService>({\n *\t\tuseFactory: (service: TokenStorageService) => ({\n *\t\t\tgetToken: service.accessToken$\n *\t\t\tautoRefresher: {\n * \t\t\t\tendpoint: `${environment.api}/auth/refresh`,\n * \t\t\t\tsetToken: (response) => service.accessToken$.next(response.accessToken)\n * \t\t\t}\n *\t\t}),\n *\t\tdeps: [TokenStorageService],\n * })\n * ```\n */\nexport interface JwtConfiguration extends Omit<HeaderConfiguration, 'getValue'>, JwtErrorHandling {\n\t/**\n\t * A callback or observable that will be called or subscribed to\n\t * on every http request and returns a value for the header\n\t *\n\t * @example getValue: () => localstorage.get('foo')\n\t * @example getValue: myTokenService.foo$\n\t */\n\tgetToken:\n\t\t| Observable<string | null | undefined>\n\t\t| (() =>\n\t\t\t\t| string\n\t\t\t\t| null\n\t\t\t\t| undefined\n\t\t\t\t| Promise<string | null | undefined>\n\t\t\t\t| Observable<string | null | undefined>);\n\n\t/**\n\t * The prefix of the token when injecting. Notice thet the trailing\n\t * whitespace has to be set here\n\t *\n\t * @default 'Bearer '\n\t */\n\tscheme?: string;\n\n\t/**\n\t * Header name to be set\n\t *\n\t * @default 'Authorization'\n\t */\n\theader: string;\n\n\t/**\n\t * Sets the 'withCredentials' to true along with the token\n\t *\n\t * @default true\n\t */\n\thandleWithCredentials: boolean;\n\n\t/**\n\t * This callback is called when the request fails and there is no\n\t * RefreshConfiguration, or when the access token is simply missing.\n\t * `getToken` returned a nullish value. If the RefreshConfiguration is\n\t * available, then the error handling continues in the same fashion on\n\t * the other configuration.\n\t *\n\t * Both have the same names and signature for\n\t * both the error handling configuration options `onFailure` and\n\t * `onFailureRedirectParameters`, so if you wish to use the same for both\n\t * implement them outside, and spread them back. You can use the\n\t * `JwtErrorHandling` interface to help you with the typing. Although\n\t * thats a bit wider when it comes to the error types.\n\t *\n\t * If it's a string, instead of calling it, a redirection will happen,\n\t * with `onFailureRedirectParameters` as it's queryParams.\n\t */\n\tonFailure?: string | ((jwtError: JwtError) => void);\n\n\tonFailureRedirectParameters?: ((error: JwtError) => HttpParams | Params) | HttpParams | Params;\n}\n"]}