{"version":3,"file":"match-against.function.js","sourceRoot":"","sources":["../../../../../../libs/jwt/src/lib/function/match-against.function.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,QAAQ,EAAE,MAAM,oBAAoB,CAAC;AAE9C,MAAM,CAAC,MAAM,SAAS,GAAG,CAAC,IAAqB,EAAE,OAAuB,EAAW,EAAE;IACpF,IAAI,QAAQ,CAAC,IAAI,CAAC,EAAE;QACnB,OAAO,IAAI,KAAK,OAAO,CAAC;KACxB;SAAM,IAAI,OAAO,EAAE;QACnB,OAAO,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;KAC1B;SAAM;QACN,OAAO,KAAK,CAAC;KACb;AACF,CAAC,CAAC;AAEF;;;GAGG;AACH,MAAM,CAAC,MAAM,YAAY,GAAG,CAAC,OAAuB,EAAE,OAAO,GAAG,KAAK,EAAE,EAAE,CAAC,CACzE,IAAqB,EACX,EAAE,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC,CAAC","sourcesContent":["import { isString } from './string.predicate';\n\nexport const matchRule = (rule: string | RegExp, against?: string | null): boolean => {\n\tif (isString(rule)) {\n\t\treturn rule === against;\n\t} else if (against) {\n\t\treturn rule.test(against);\n\t} else {\n\t\treturn false;\n\t}\n};\n\n/**\n *\n * @param inverse easy negating when composing\n */\nexport const matchAgainst = (against?: string | null, inverse = false) => (\n\trule: string | RegExp\n): boolean => (inverse ? !matchRule(rule, against) : matchRule(rule, against));\n"]}