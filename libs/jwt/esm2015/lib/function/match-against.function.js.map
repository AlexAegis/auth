{"version":3,"file":"match-against.function.js","sourceRoot":"","sources":["../../../../../../libs/jwt/src/lib/function/match-against.function.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,QAAQ,EAAE,MAAM,oBAAoB,CAAC;AAE9C,MAAM,CAAC,MAAM,SAAS,GAAG,CAAC,IAAqB,EAAE,OAAuB,EAAW,EAAE;IACpF,IAAI,QAAQ,CAAC,IAAI,CAAC,EAAE;QACnB,OAAO,IAAI,KAAK,OAAO,CAAC;KACxB;SAAM,IAAI,OAAO,EAAE;QACnB,OAAO,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;KAC1B;SAAM;QACN,OAAO,KAAK,CAAC;KACb;AACF,CAAC,CAAC;AAEF;;;GAGG;AACH,MAAM,CAAC,MAAM,YAAY,GACxB,CAAC,OAAuB,EAAE,OAAO,GAAG,KAAK,EAAE,EAAE,CAC7C,CAAC,IAAqB,EAAW,EAAE,CAClC,OAAO,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC","sourcesContent":["import { isString } from './string.predicate';\n\nexport const matchRule = (rule: string | RegExp, against?: string | null): boolean => {\n\tif (isString(rule)) {\n\t\treturn rule === against;\n\t} else if (against) {\n\t\treturn rule.test(against);\n\t} else {\n\t\treturn false;\n\t}\n};\n\n/**\n *\n * @param inverse easy negating when composing\n */\nexport const matchAgainst =\n\t(against?: string | null, inverse = false) =>\n\t(rule: string | RegExp): boolean =>\n\t\tinverse ? !matchRule(rule, against) : matchRule(rule, against);\n"]}