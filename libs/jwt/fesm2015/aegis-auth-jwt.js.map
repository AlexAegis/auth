{"version":3,"file":"aegis-auth-jwt.js","sources":["../../libs/jwt/src/lib/function/is-unix-timestamp-expired.function.ts","../../libs/jwt/src/lib/model/header-configuration.interface.ts","../../libs/jwt/src/lib/model/auth-core-configuration.interface.ts","../../libs/jwt/src/lib/errors/jwt-error.class.ts","../../libs/jwt/src/lib/function/string.predicate.ts","../../libs/jwt/src/lib/function/handle-jwt-failure.function.ts","../../libs/jwt/src/lib/function/is-not-nullish.predicate.ts","../../libs/jwt/src/lib/function/handle-jwt-error.function.ts","../../libs/jwt/src/lib/function/function.predicate.ts","../../libs/jwt/src/lib/function/promise.predicate.ts","../../libs/jwt/src/lib/function/into-observable.function.ts","../../libs/jwt/src/lib/function/is-timestamp-expired-now-and-when-it-is.function.ts","../../libs/jwt/src/lib/function/is-unix-timestamp-expired-now-and-when-it-is.function.ts","../../libs/jwt/src/lib/function/check-against-http-error-filter.function.ts","../../libs/jwt/src/lib/function/call-when-function.function.ts","../../libs/jwt/src/lib/function/http-response.predicate.ts","../../libs/jwt/src/lib/function/do-jwt-refresh.function.ts","../../libs/jwt/src/lib/function/try-jwt-refresh.function.ts","../../libs/jwt/src/lib/function/base64-decoder.function.ts","../../libs/jwt/src/lib/model/jwt-token.class.ts","../../libs/jwt/src/lib/token/jwt-configuration.token.ts","../../libs/jwt/src/lib/service/jwt-token.service.ts","../../libs/jwt/src/lib/guards/login.guard.ts","../../libs/jwt/src/lib/interceptor/jwt-error-handling.interceptor.ts","../../libs/jwt/src/lib/function/match-against.function.ts","../../libs/jwt/src/lib/function/check-against-url-filter.function.ts","../../libs/jwt/src/lib/function/separate-url.function.ts","../../libs/jwt/src/lib/interceptor/jwt-injector.interceptor.ts","../../libs/jwt/src/lib/interceptor/jwt-refresh.interceptor.ts","../../libs/jwt/src/lib/providers/create-jwt-configuration-provider.function.ts","../../libs/jwt/src/lib/providers/create-jwt-refresh-configuration-provider.function.ts","../src/lib/jwt.module.ts","../../libs/jwt/src/lib/model/http-method.enum.ts","../../../../libs/jwt/src/aegis-auth-jwt.ts"],"sourcesContent":["/**\n *\n * @param unixTimestamp seconds from the unix epoch 1970-01-01T00:00:00Z\n * if not supplied it will always be expired\n */\nexport const isUnixTimestampExpired = (unixTimestamp = -Infinity): boolean =>\n\tunixTimestamp < Math.floor(new Date().getTime() / 1000);\n","import { BehaviorSubject, Observable } from 'rxjs';\n\nexport const DEFAULT_HEADER_CONFIG: Partial<HeaderConfiguration> = {\n\tgetValue: new BehaviorSubject<string | null | undefined>(null),\n};\n\nexport interface NormalizedHeaderConfiguration extends HeaderConfiguration {\n\tvalue$: Observable<string | null | undefined>;\n}\n\n/**\n * Token injection configuration\n *\n * The optional generic defined the refresh endpoints Response type. If you\n * are not using that feature there's no need to define it.\n *\n * Example configuration:\n * ```typescript\n * AuthCoreModule.forRoot<TokenStorageService>({\n *\t\tuseFactory: (service: TokenStorageService) => ({\n *\t\t\tgetToken: service.accessToken$\n *\t\t\tautoRefresher: {\n * \t\t\t\tendpoint: `${environment.api}/auth/refresh`,\n * \t\t\t\tsetToken: (response) => service.accessToken$.next(response.accessToken)\n * \t\t\t}\n *\t\t}),\n *\t\tdeps: [TokenStorageService],\n * })\n * ```\n */\nexport interface HeaderConfiguration extends UrlFilter {\n\t/**\n\t * A callback or observable that will be called or subscribed to\n\t * on every http request and returns a value for the header\n\t *\n\t * @example getValue: () => localstorage.get('foo')\n\t * @example getValue: myTokenService.foo$\n\t */\n\tgetValue:\n\t\t| Observable<string | null | undefined>\n\t\t| (() =>\n\t\t\t\t| string\n\t\t\t\t| null\n\t\t\t\t| undefined\n\t\t\t\t| Promise<string | null | undefined>\n\t\t\t\t| Observable<string | null | undefined>);\n\n\t/**\n\t * Header name to be set\n\t */\n\theader: string;\n}\n\nexport interface UrlFilter {\n\t/**\n\t * These domains won't recieve this header even if they are listed in the\n\t * whitelist.\n\t *\n\t * If `null` or `undefined`, this category of rules won't take any effect.\n\t * If empty, it would mean \"No domains are blacklisted\", and it won't\n\t * take any effect.\n\t *\n\t * @default undefined\n\t * @example ['localhost:3333']\n\t * @example [/localhost:[0-9]{4}/]\n\t */\n\tdomainBlacklist?: (string | RegExp)[];\n\n\t/**\n\t * Only domains listed will be recieving header injections\n\t *\n\t * If `null` or `undefined`, this category of rules won't take any effect.\n\t * If empty, it would mean \"No domains are whitelisted\", so no paths would\n\t * recieve tokens!\n\t *\n\t * @default undefined\n\t * @example ['localhost:3333']\n\t * @example [/localhost:[0-9]{4}/]\n\t */\n\tdomainWhitelist?: (string | RegExp)[];\n\n\t/**\n\t * These paths won't recieve this header even if they are listed in the\n\t * whitelist.\n\t *\n\t * If `null` or `undefined`, this category of rules won't take any effect.\n\t * If empty, it would mean \"No paths are blacklisted\", and it won't\n\t * take any effect.\n\t *\n\t * @default undefined\n\t * @example ['api/v2/users/1']\n\t * @example [/users\\/.+/]\n\t */\n\tpathBlacklist?: (string | RegExp)[];\n\n\t/**\n\t * Only paths listed will be recieving this header injection.\n\t *\n\t * If `null` or `undefined`, this category of rules won't take any effect.\n\t * If empty, it would mean \"No paths are whitelisted\", so no paths would\n\t * recieve tokens!\n\t *\n\t * @default undefined\n\t * @example ['api/v2/users/1']\n\t * @example [/users\\/.+/]\n\t */\n\tpathWhitelist?: (string | RegExp)[];\n\n\t/**\n\t * These protocols won't recieve this header even if they are listed in\n\t * the whitelist.\n\t *\n\t * If `null` or `undefined`, this category of rules won't take any effect.\n\t * If empty, it would mean \"No protocols are blacklisted\", and it won't\n\t * take any effect.\n\t *\n\t * @default undefined\n\t * @example ['http']\n\t * @example [/https?/]\n\t */\n\tprotocolBlacklist?: (string | RegExp)[];\n\n\t/**\n\t * Only protocols listed will be recieving this header injections.\n\t *\n\t * If empty or undefined, this category of rules won't take any effect.\n\t * If empty, it would mean \"No protocols are whitelisted\", so no protocols\n\t * would recieve tokens!\n\t *\n\t * @default undefined\n\t * @example ['http']\n\t * @example [/https?/]\n\t */\n\tprotocolWhitelist?: (string | RegExp)[];\n}\n","import { HttpHeaders, HttpParams } from '@angular/common/http';\nimport { Params } from '@angular/router';\nimport { Observable } from 'rxjs';\nimport { JwtCannotRefreshError, JwtCouldntRefreshError, JwtError } from '../errors/jwt-error.class';\nimport {\n\tDEFAULT_HEADER_CONFIG,\n\tHeaderConfiguration,\n\tUrlFilter,\n} from '../model/header-configuration.interface';\nimport { HttpMethodType } from './http-method.enum';\n\nexport const DEFAULT_JWT_HEADER = 'Authorization';\nexport const DEFAULT_JWT_SCHEME = 'Bearer ';\n\nexport const DEFAULT_JWT_CONFIG: Partial<JwtConfiguration> = {\n\t...DEFAULT_HEADER_CONFIG,\n\theader: DEFAULT_JWT_HEADER,\n\tscheme: DEFAULT_JWT_SCHEME,\n\thandleWithCredentials: true,\n};\n\nexport const DEFAULT_JWT_REFRESH_CONFIG_DEFAULT_AUTO_IN_GUARD = true;\n\nexport const DEFAULT_JWT_REFRESH_CONFIG: Partial<JwtRefreshConfiguration<unknown, unknown>> = {\n\tmethod: 'POST',\n\terrorCodeWhitelist: [401],\n\tisAutoRefreshAllowedInLoginGuardByDefault: DEFAULT_JWT_REFRESH_CONFIG_DEFAULT_AUTO_IN_GUARD,\n};\n\nexport interface JwtRefreshResponse {\n\taccessToken: string;\n\trefreshToken?: string;\n}\n\nexport interface HttpRequestInit {\n\theaders?: HttpHeaders;\n\treportProgress?: boolean;\n\tparams?: HttpParams;\n\tresponseType?: 'arraybuffer' | 'blob' | 'json' | 'text';\n\twithCredentials?: boolean;\n}\n\n/**\n * TODO: optional generic matcher function\n */\nexport interface HttpErrorFilter {\n\t/**\n\t * The error codes on which an act is allowed to happen,\n\t * an empty array means it can't act on anything\n\t *\n\t * @default [401]\n\t */\n\terrorCodeWhitelist?: number[];\n\n\t/**\n\t * The error codes on which an act is not allowed to happen,\n\t * an empty array (and if undefined) means it can always try a single\n\t * act in case of an error\n\t *\n\t * @default undefined\n\t */\n\terrorCodeBlacklist?: number[];\n}\n\n/**\n * Enables the RefreshInterceptor which will automatically tries to\n * refresh the accessToken on expiration or failure of the next request.\n *\n * Because handling refreshes is not standardized, instead of asking for the\n * refresh token directly I ask you to provide the request itself, however you\n * like to. In these callbacks you can access your refreshToken wherever you\n * store it.\n *\n * You can still configure a `getRefreshToken` property but it's optional,\n * not used in the interceptor at all, and is only used in the helper service.\n * If you do not with to interact with the parsed refreshToken (Usually you\n * don't need to) you can leave that out. But it's there if you might need it.\n *\n * The reason it's configured through multiple properties instead of a callback\n * where I let you do the refresh request however you see fit is to make sure the\n * refreshUrl is known to avoid potentional infinite requests when hitting the\n * refresh endpoint. This way you don't have to remember setting this into the\n * url filter manually.\n *\n * @example configuration.\n * AuthCoreModule.forRoot<TokenStorageService>({\n *\t\tuseFactory: (service: TokenStorageService) => ({\n *\t\t\tgetToken: service.accessToken$\n *\t\t\tautoRefresher: {\n * \t\t\t\tendpoint: `${environment.api}/auth/refresh`,\n * \t\t\t\tsetToken: (response) => service.accessToken$.next(response.accessToken)\n * \t\t\t}\n *\t\t}),\n *\t\tdeps: [TokenStorageService],\n * })\n *\n * @default undefined\n */\nexport interface JwtRefreshConfiguration<RefreshRequest, RefreshResponse>\n\textends UrlFilter,\n\t\tHttpErrorFilter {\n\t/**\n\t * After a successful refresh, this callback will be called.\n\t * You need to define a function which will save the the token in a way\n\t * that if the interceptor calls `getToken` again, it will get the token\n\t * saved with this method.\n\t *\n\t * @example using `localStorage`\n\t * \t\tsetToken: (response) => localStorage.setItem('accessToken', response.accessToken)\n\t * @example using a service.\n\t *\n\t * ```typescript\n\t * AuthCoreModule.forRoot<TokenStorageService>({\n\t *\t\tuseFactory: (service: TokenStorageService) => ({\n\t *\t\t\tgetToken: service.accessToken$\n\t *\t\t\tautoRefresher: {\n\t * \t\t\t\tendpoint: `${environment.api}/auth/refresh`,\n\t * \t\t\t\tsetRefreshToken: (response) => service.accessToken$.next(response.accessToken)\n\t * \t\t\t}\n\t *\t\t}),\n\t *\t\tdeps: [TokenStorageService],\n\t * })\n\t * ```\n\t *\n\t */\n\tsetRefreshedTokens: (response: JwtRefreshResponse) => void;\n\n\t/**\n\t * The method for the request, usually it's a POST so that's the default\n\t *\n\t * @default 'POST'\n\t */\n\tmethod?: HttpMethodType;\n\n\t/**\n\t * The endpoint that will be requested for a new token\n\t */\n\trefreshUrl: string;\n\n\t/**\n\t * A callback or observable that can be used to retrieve the body of the\n\t * request. If it's null or undefined, the refresh won't be executed. This\n\t * can be utilized to not do a refresh on a logged out state.\n\t *\n\t * @example getValue: () => localstorage.get('foo')\n\t * @example getValue: myTokenService.foo$\n\t */\n\tcreateRefreshRequestBody:\n\t\t| Observable<RefreshRequest | null | undefined>\n\t\t| (() =>\n\t\t\t\t| RefreshRequest\n\t\t\t\t| null\n\t\t\t\t| undefined\n\t\t\t\t| Promise<RefreshRequest | null | undefined>\n\t\t\t\t| Observable<RefreshRequest | null | undefined>);\n\n\t/**\n\t * A callback that should return the defaults on the request\n\t */\n\trefreshRequestInitials?: (() => HttpRequestInit | undefined) | HttpRequestInit;\n\n\t/**\n\t * This function have to transform the result of your refresh endpoint\n\t * into a digestable form. It will be called after successful refreshes.\n\t */\n\ttransformRefreshResponse: (response: RefreshResponse) => JwtRefreshResponse;\n\n\t/**\n\t * This callback is called when a refresh either failed or cannot be done.\n\t * This marks the point where both tokens are invalid and the user needs to\n\t * relog. Because this is usually done through a login page, aside from a\n\t * regular callback, a string can also be supplied which will act as the\n\t * target of navigation. Check `onFailureRedirectParameters` if you wish\n\t * to supply query parameters. For more advanced usage, consider\n\t * implementing it as a custom function, the error object is available\n\t * there too!\n\t */\n\tonFailure?: string | ((error: JwtCouldntRefreshError | JwtCannotRefreshError) => void);\n\n\tonFailureRedirectParameters?:\n\t\t| ((error: JwtCouldntRefreshError | JwtCannotRefreshError) => HttpParams | Params)\n\t\t| HttpParams\n\t\t| Params;\n\n\t/**\n\t * Optional!\n\t *\n\t * The refresh mechanic only uses this to determine if it's expired or not\n\t * and so potentionally saving a request that would fail anyway. It is\n\t * also used in the helper service if you with to interact with the\n\t * parsed refreshToken throught the helper observables. If you do not\n\t * need either of these, you don't have to implement this.\n\t *\n\t * A callback or observable that can be used to retrieve the refresh token\n\t * Not used in the interceptor!\n\t *\n\t * @example getValue: () => localstorage.get('foo')\n\t * @example getValue: myTokenService.foo$\n\t */\n\tgetRefreshToken?:\n\t\t| Observable<string | null | undefined>\n\t\t| (() =>\n\t\t\t\t| string\n\t\t\t\t| null\n\t\t\t\t| undefined\n\t\t\t\t| Promise<string | null | undefined>\n\t\t\t\t| Observable<string | null | undefined>);\n\n\t/**\n\t * When using the LoginGuard this setting will determine the default\n\t * value. So instead of disabling the autoRefresh behavior on every\n\t * route with the data option, or writing your own guard (Which would\n\t * be really simple) just set this to false. You can still override it\n\t * using route data.\n\t *\n\t * See the LoginGuardData helper interface to see what it can utilize.\n\t *\n\t * @default true\n\t */\n\tisAutoRefreshAllowedInLoginGuardByDefault?: boolean;\n}\n\n/**\n * This is a helper interface because they look the same on both\n * `JwtConfiguration` and `JwtRefreshConfiguration`. They are re-defined\n * on them to provide better documentation.\n *\n * In the case where you wish to implement them both in a separate object\n * then spread it back to both to reduce code-duplication, this type can\n * be utilized.\n */\nexport interface JwtErrorHandling {\n\t/**\n\t * If it's a string, instead of calling it, a redirection will happen,\n\t * with `onFailureRedirectParameters` as it's queryParams.\n\t */\n\tonFailure?:\n\t\t| string\n\t\t| ((jwtError: JwtError | JwtCouldntRefreshError | JwtCannotRefreshError) => void);\n\n\t/**\n\t * This option is only used when the `onFailure` option is a string\n\t * so it's handled as a redirect. When this happens, you can define\n\t * the queryparams to be used with this redirect.\n\t *\n\t * When implemented as a function, the JwtError will be forwarded to it.\n\t * All JwtErrors have the `originalRequest` available in them, so it's\n\t * trivial to acquire the failed url.\n\t */\n\tonFailureRedirectParameters?:\n\t\t| ((\n\t\t\t\terror: JwtError | JwtCouldntRefreshError | JwtCannotRefreshError\n\t\t  ) => HttpParams | Params)\n\t\t| HttpParams\n\t\t| Params;\n}\n\n/**\n * Token injection configuration\n *\n * The optional generic defined the refresh endpoints Response type. If you\n * are not using that feature there's no need to define it.\n *\n * Example configuration:\n * ```typescript\n * AuthCoreModule.forRoot<TokenStorageService>({\n *\t\tuseFactory: (service: TokenStorageService) => ({\n *\t\t\tgetToken: service.accessToken$\n *\t\t\tautoRefresher: {\n * \t\t\t\tendpoint: `${environment.api}/auth/refresh`,\n * \t\t\t\tsetToken: (response) => service.accessToken$.next(response.accessToken)\n * \t\t\t}\n *\t\t}),\n *\t\tdeps: [TokenStorageService],\n * })\n * ```\n */\nexport interface JwtConfiguration extends Omit<HeaderConfiguration, 'getValue'>, JwtErrorHandling {\n\t/**\n\t * A callback or observable that will be called or subscribed to\n\t * on every http request and returns a value for the header\n\t *\n\t * @example getValue: () => localstorage.get('foo')\n\t * @example getValue: myTokenService.foo$\n\t */\n\tgetToken:\n\t\t| Observable<string | null | undefined>\n\t\t| (() =>\n\t\t\t\t| string\n\t\t\t\t| null\n\t\t\t\t| undefined\n\t\t\t\t| Promise<string | null | undefined>\n\t\t\t\t| Observable<string | null | undefined>);\n\n\t/**\n\t * The prefix of the token when injecting. Notice thet the trailing\n\t * whitespace has to be set here\n\t *\n\t * @default 'Bearer '\n\t */\n\tscheme?: string;\n\n\t/**\n\t * Header name to be set\n\t *\n\t * @default 'Authorization'\n\t */\n\theader: string;\n\n\t/**\n\t * Sets the 'withCredentials' to true along with the token\n\t *\n\t * @default true\n\t */\n\thandleWithCredentials: boolean;\n\n\t/**\n\t * This callback is called when the request fails and there is no\n\t * RefreshConfiguration, or when the access token is simply missing.\n\t * `getToken` returned a nullish value. If the RefreshConfiguration is\n\t * available, then the error handling continues in the same fashion on\n\t * the other configuration.\n\t *\n\t * Both have the same names and signature for\n\t * both the error handling configuration options `onFailure` and\n\t * `onFailureRedirectParameters`, so if you wish to use the same for both\n\t * implement them outside, and spread them back. You can use the\n\t * `JwtErrorHandling` interface to help you with the typing. Although\n\t * thats a bit wider when it comes to the error types.\n\t *\n\t * If it's a string, instead of calling it, a redirection will happen,\n\t * with `onFailureRedirectParameters` as it's queryParams.\n\t */\n\tonFailure?: string | ((jwtError: JwtError) => void);\n\n\tonFailureRedirectParameters?: ((error: JwtError) => HttpParams | Params) | HttpParams | Params;\n}\n","import { HttpErrorResponse, HttpRequest } from '@angular/common/http';\n\nexport class JwtError extends Error {\n\tstatic type = 'JWT_ERROR';\n\n\tpublic constructor(\n\t\tpublic readonly originalRequest: HttpRequest<unknown> | undefined,\n\t\tpublic readonly originalError: unknown,\n\t\tmessage = JwtError.type\n\t) {\n\t\tsuper(message);\n\t}\n\n\tstatic createErrorResponse(\n\t\trequest: HttpRequest<unknown> | undefined,\n\t\trefreshError: unknown\n\t): HttpErrorResponse {\n\t\treturn new HttpErrorResponse({\n\t\t\terror: JwtError.createErrorEvent(request, refreshError),\n\t\t});\n\t}\n\n\tstatic createErrorEvent(\n\t\trequest: HttpRequest<unknown> | undefined,\n\t\trefreshError: unknown\n\t): ErrorEvent {\n\t\treturn new ErrorEvent(JwtError.type, {\n\t\t\terror: new JwtError(request, refreshError),\n\t\t});\n\t}\n}\n\n/**\n * When both access and refresh tokens are either invalid or expired!\n */\nexport class JwtCannotRefreshError extends JwtError {\n\tstatic type = 'JWT_CANNOT_REFRESH_ERROR';\n\n\tpublic constructor(\n\t\tpublic readonly originalRequest: HttpRequest<unknown> | undefined,\n\t\tpublic readonly originalError: unknown\n\t) {\n\t\tsuper(originalRequest, originalError, JwtCannotRefreshError.type);\n\t}\n\n\tstatic createErrorResponse(\n\t\trequest: HttpRequest<unknown> | undefined,\n\t\trefreshError: unknown\n\t): HttpErrorResponse {\n\t\treturn new HttpErrorResponse({\n\t\t\terror: JwtCannotRefreshError.createErrorEvent(request, refreshError),\n\t\t});\n\t}\n\n\tstatic createErrorEvent(\n\t\trequest: HttpRequest<unknown> | undefined,\n\t\trefreshError: unknown\n\t): ErrorEvent {\n\t\treturn new ErrorEvent(JwtCannotRefreshError.type, {\n\t\t\terror: new JwtCannotRefreshError(request, refreshError),\n\t\t});\n\t}\n}\n\n/**\n * When refresh failed\n */\nexport class JwtCouldntRefreshError extends JwtError {\n\tstatic type = 'JWT_COULDNT_REFRESH_ERROR';\n\n\tpublic constructor(\n\t\tpublic readonly originalRequest: HttpRequest<unknown> | undefined,\n\t\tpublic readonly originalError: unknown\n\t) {\n\t\tsuper(originalRequest, originalError, JwtCouldntRefreshError.type);\n\t}\n\n\tstatic createErrorResponse(\n\t\trequest: HttpRequest<unknown> | undefined,\n\t\trefreshError: unknown\n\t): HttpErrorResponse {\n\t\treturn new HttpErrorResponse({\n\t\t\terror: JwtCouldntRefreshError.createErrorEvent(request, refreshError),\n\t\t});\n\t}\n\n\tstatic createErrorEvent(\n\t\trequest: HttpRequest<unknown> | undefined,\n\t\trefreshError: unknown\n\t): ErrorEvent {\n\t\treturn new ErrorEvent(JwtCouldntRefreshError.type, {\n\t\t\terror: new JwtCouldntRefreshError(request, refreshError),\n\t\t});\n\t}\n}\n","export const isString = (stringLike: unknown): stringLike is string =>\n\ttypeof stringLike === 'string';\n","import { HttpParams } from '@angular/common/http';\nimport { Params, Router } from '@angular/router';\nimport { isString } from '../function/string.predicate';\n\n/**\n * Jwt failures are handled by either calling a callback or if its a string,\n * redirect\n *\n * @internal\n */\nexport const handleJwtFailure = <E>(\n\terrorCallbackOrRedirect: string | ((e: E) => void),\n\terror: E,\n\trouter?: Router,\n\tredirectParameters?: ((e: E) => HttpParams | Params) | HttpParams | Params\n): void => {\n\tif (isString(errorCallbackOrRedirect)) {\n\t\tif (router) {\n\t\t\tlet queryParams = redirectParameters;\n\t\t\tif (typeof redirectParameters === 'function') {\n\t\t\t\tqueryParams = redirectParameters(error);\n\t\t\t}\n\n\t\t\trouter.navigate([errorCallbackOrRedirect], {\n\t\t\t\tqueryParams,\n\t\t\t});\n\t\t} else {\n\t\t\t// This error is intended to surface as it's a configuration problem\n\t\t\tthrow new Error(\n\t\t\t\t'JWT Refresh configuration error! ' +\n\t\t\t\t\t'`onFailure` is defined as a string, but the ' +\n\t\t\t\t\t'Router is not available! Is @angular/router ' +\n\t\t\t\t\t'installed and the RouterModule imported?'\n\t\t\t);\n\t\t}\n\t} else {\n\t\terrorCallbackOrRedirect(error);\n\t}\n};\n","export const isNotNullish = <T>(t: T | undefined | null): t is T => t !== undefined && t !== null;\n","import { HttpErrorResponse } from '@angular/common/http';\nimport { Router } from '@angular/router';\nimport { Observable, throwError } from 'rxjs';\nimport { JwtCannotRefreshError, JwtCouldntRefreshError, JwtError } from '../errors/jwt-error.class';\nimport {\n\tJwtConfiguration,\n\tJwtRefreshConfiguration,\n} from '../model/auth-core-configuration.interface';\nimport { handleJwtFailure } from './handle-jwt-failure.function';\nimport { isNotNullish } from './is-not-nullish.predicate';\n\nexport const handleJwtError = <RefreshRequest = unknown, RefreshResponse = unknown>(\n\twrappedError:\n\t\t| (Omit<HttpErrorResponse, 'error'> & {\n\t\t\t\terror?: Omit<ErrorEvent, 'error'> & {\n\t\t\t\t\terror: JwtError | JwtCannotRefreshError | JwtCouldntRefreshError;\n\t\t\t\t};\n\t\t  })\n\t\t| { error?: { error: JwtError | JwtCannotRefreshError | JwtCouldntRefreshError } },\n\tjwtConfiguration: JwtConfiguration,\n\tjwtRefreshConfiguration?: JwtRefreshConfiguration<RefreshRequest, RefreshResponse>,\n\trouter?: Router\n): Observable<never> => {\n\tconst error: undefined | JwtError | JwtCannotRefreshError | JwtCouldntRefreshError =\n\t\twrappedError.error?.error;\n\n\tif (error instanceof JwtCannotRefreshError || error instanceof JwtCouldntRefreshError) {\n\t\tif (jwtRefreshConfiguration && isNotNullish(jwtRefreshConfiguration.onFailure)) {\n\t\t\thandleJwtFailure(\n\t\t\t\tjwtRefreshConfiguration.onFailure,\n\t\t\t\terror,\n\t\t\t\trouter,\n\t\t\t\tjwtRefreshConfiguration.onFailureRedirectParameters\n\t\t\t);\n\t\t}\n\t\t// Rethrow the inner error, so observers of the user can see it\n\t\treturn throwError(error);\n\t} else if (error instanceof JwtError) {\n\t\tif (isNotNullish(jwtConfiguration.onFailure)) {\n\t\t\thandleJwtFailure(\n\t\t\t\tjwtConfiguration.onFailure,\n\t\t\t\terror,\n\t\t\t\trouter,\n\t\t\t\tjwtConfiguration.onFailureRedirectParameters\n\t\t\t);\n\t\t}\n\t\treturn throwError(error);\n\t} else {\n\t\t// Other errors are left untreated\n\t\treturn throwError(wrappedError);\n\t}\n};\n","export const isFunction = <Return>(funlike: unknown): funlike is () => Return =>\n\ttypeof funlike === 'function';\n","/**\n * Returns true if the object is truthy and has a `then` and a `catch` function.\n * Using `instanceof` would not be sufficient as Promises can be contructed\n * in many ways, and it's just a specification.\n */\nexport const isPromise = <T>(promiseLike: unknown): promiseLike is Promise<T> =>\n\tpromiseLike &&\n\ttypeof (promiseLike as Promise<T>).then === 'function' &&\n\ttypeof (promiseLike as Promise<T>).catch === 'function';\n","import { from, isObservable, Observable, of } from 'rxjs';\nimport { switchMap } from 'rxjs/operators';\nimport { isFunction } from './function.predicate';\nimport { isPromise } from './promise.predicate';\n\n/**\n * Returns a cold observable from a function, or returns an observable if\n * one is directly passed to it\n */\nexport const intoObservable = <T>(\n\tgetValue: T | Observable<T> | Promise<T> | (() => T | Promise<T> | Observable<T>)\n): Observable<T> => {\n\tif (isObservable(getValue)) {\n\t\treturn getValue;\n\t} else if (isFunction(getValue)) {\n\t\treturn of(null).pipe(\n\t\t\tswitchMap(() => {\n\t\t\t\tconst result = getValue();\n\t\t\t\tif (isObservable(result)) {\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t\tif (isPromise(result)) {\n\t\t\t\t\treturn from(result);\n\t\t\t\t} else {\n\t\t\t\t\treturn of(result);\n\t\t\t\t}\n\t\t\t})\n\t\t);\n\t} else if (isPromise(getValue)) {\n\t\treturn from(getValue);\n\t} else {\n\t\treturn of(getValue);\n\t}\n};\n","import { merge, Observable, of, timer } from 'rxjs';\nimport { mapTo } from 'rxjs/operators';\n\n/**\n * It returns an observable which emits instantly a boolean describing if the\n * timestamp is expired or not. If not, it will emit a second time when it\n * will expire.\n *\n * @param timestamp milliseconds\n */\nexport const isTimestampExpiredNowAndWhenItIs = (timestamp: number): Observable<boolean> => {\n\t// If already expired, just return that\n\tif (timestamp - new Date().getTime() < 0) {\n\t\treturn of(true);\n\t} else {\n\t\t// If not, return that is not and a timer that will emit when it does\n\t\treturn merge(of(false), timer(new Date(timestamp)).pipe(mapTo(true)));\n\t}\n};\n","import { Observable } from 'rxjs';\nimport { isTimestampExpiredNowAndWhenItIs } from './is-timestamp-expired-now-and-when-it-is.function';\n\n/**\n * It returns an observable which emits instantly a boolean describing if the\n * timestamp is expired or not. If not, it will emit a second time when it\n * will expire.\n *\n * @param unixTimestamp seconds from the unix epoch 1970-01-01T00:00:00Z\n * if not supplied it will always be expired\n */\nexport const isUnixTimestampExpiredNowAndWhenItIs = (unixTimestamp: number): Observable<boolean> =>\n\tisTimestampExpiredNowAndWhenItIs(Math.floor(unixTimestamp * 1000));\n","import { HttpErrorResponse } from '@angular/common/http';\nimport { HttpErrorFilter } from '../model/auth-core-configuration.interface';\n\n/**\n * Matches the filter against an error response. Non-existend rulesets\n * automatically pass. **Empty whitelist rulesets never pass.** Empty blacklist\n * rulesets always pass.\n */\nexport const checkAgainstHttpErrorFilter = (\n\thttpErrorFilter: HttpErrorFilter,\n\terror: HttpErrorResponse\n): boolean => {\n\tconst statusMatcher = (code: number) => code === error.status;\n\tconst errorCodeWhitelistRulesPass =\n\t\thttpErrorFilter.errorCodeWhitelist?.some(statusMatcher) ?? true;\n\n\tconst errorCodeBlacklistRulesPass = !httpErrorFilter.errorCodeBlacklist?.some(statusMatcher);\n\n\treturn errorCodeWhitelistRulesPass && errorCodeBlacklistRulesPass;\n};\n","import { isFunction } from './function.predicate';\n\nexport const callWhenFunction = <T = unknown>(functionLike: (() => T) | T): T => {\n\tlet result;\n\tif (isFunction<T>(functionLike)) {\n\t\tresult = functionLike();\n\t} else {\n\t\tresult = functionLike;\n\t}\n\treturn result;\n};\n","import { HttpEvent, HttpEventType, HttpResponse } from '@angular/common/http';\n\nexport const isHttpResponse = <T>(httpEvent: HttpEvent<T>): httpEvent is HttpResponse<T> =>\n\thttpEvent.type === HttpEventType.Response;\n","import { HttpHandler, HttpRequest } from '@angular/common/http';\nimport { Observable } from 'rxjs';\nimport { catchError, filter, map, mergeMap, tap } from 'rxjs/operators';\nimport {\n\tJwtRefreshConfiguration,\n\tJwtRefreshResponse,\n} from '../model/auth-core-configuration.interface';\nimport { callWhenFunction } from './call-when-function.function';\nimport { isHttpResponse } from './http-response.predicate';\n\nexport const doJwtRefresh = <Req, Res, Ret>(\n\tnext: HttpHandler,\n\trequestBody: Req,\n\tjwtRefreshConfiguration: JwtRefreshConfiguration<Req, Res>,\n\tonError: (refreshError: unknown) => Observable<Ret>,\n\toriginalAction: (refreshResponse: JwtRefreshResponse) => Observable<Ret>\n): Observable<Ret> => {\n\tconst refreshRequest = new HttpRequest<Req>(\n\t\tjwtRefreshConfiguration.method ?? 'POST',\n\t\tjwtRefreshConfiguration.refreshUrl,\n\t\trequestBody,\n\t\tcallWhenFunction(jwtRefreshConfiguration.refreshRequestInitials)\n\t);\n\n\treturn next.handle(refreshRequest).pipe(\n\t\tfilter(isHttpResponse),\n\t\tmap((response) => jwtRefreshConfiguration.transformRefreshResponse(response.body)),\n\t\ttap((refreshResponse) => jwtRefreshConfiguration.setRefreshedTokens(refreshResponse)),\n\t\tmergeMap((refreshResponse) => originalAction(refreshResponse)),\n\t\tcatchError(onError)\n\t);\n};\n","import { HttpErrorResponse, HttpHandler } from '@angular/common/http';\nimport { Observable, throwError } from 'rxjs';\nimport { switchMap, take } from 'rxjs/operators';\nimport {\n\tJwtRefreshConfiguration,\n\tJwtRefreshResponse,\n} from '../model/auth-core-configuration.interface';\nimport { checkAgainstHttpErrorFilter } from './check-against-http-error-filter.function';\nimport { doJwtRefresh } from './do-jwt-refresh.function';\nimport { intoObservable } from './into-observable.function';\n\nexport const tryJwtRefresh = <Req, Res, Ret>(\n\tnext: HttpHandler,\n\toriginalError: string | HttpErrorResponse,\n\tjwtRefreshConfiguration: JwtRefreshConfiguration<Req, Res>,\n\tonError: (refreshError: unknown) => Observable<Ret>,\n\toriginalAction: (refreshResponse: JwtRefreshResponse) => Observable<Ret>\n): Observable<Ret> => {\n\tconst isRefreshAllowed =\n\t\ttypeof originalError === 'string' ||\n\t\tcheckAgainstHttpErrorFilter(jwtRefreshConfiguration, originalError);\n\tif (isRefreshAllowed) {\n\t\treturn intoObservable(jwtRefreshConfiguration.createRefreshRequestBody).pipe(\n\t\t\ttake(1),\n\t\t\tswitchMap((requestBody) => {\n\t\t\t\tif (requestBody) {\n\t\t\t\t\treturn doJwtRefresh(\n\t\t\t\t\t\tnext,\n\t\t\t\t\t\trequestBody,\n\t\t\t\t\t\tjwtRefreshConfiguration,\n\t\t\t\t\t\tonError,\n\t\t\t\t\t\toriginalAction\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\treturn onError(originalError);\n\t\t\t\t}\n\t\t\t})\n\t\t);\n\t} else {\n\t\treturn throwError(originalError);\n\t}\n};\n","import { Base64 } from 'js-base64';\n\nexport type Base64String = string;\nexport type JsonString = string;\n\n/**\n *\n * @param str json encoded in Base64\n */\nexport const decodeJsonLikeBase64 = <T = Record<string, unknown>>(str: Base64String): T | null => {\n\ttry {\n\t\treturn JSON.parse(Base64.decode(str));\n\t} catch (error) {\n\t\tconsole.error('Invalid Jsonlike Base64 string', error);\n\t\treturn null;\n\t}\n};\n","import { Base64 } from 'js-base64';\nimport { Base64String, decodeJsonLikeBase64 } from '../function/base64-decoder.function';\nimport { isUnixTimestampExpired } from '../function/is-unix-timestamp-expired.function';\n\nexport type JwtTokenString = string;\nexport type UnixTime = number;\n\nexport interface JwtTokenHeader {\n\t/**\n\t * Media type\n\t */\n\ttyp?: string;\n\t/**\n\t * Content Type\n\t */\n\tcty?: 'JWT' | string;\n\t/**\n\t * Algorithm\n\t */\n\talg: string;\n\t/**\n\t * Encryption\n\t */\n\tenc?: string;\n}\n\n/**\n * Registered claim names defined in RFC 7519 are predefined here.\n */\nexport interface JwtTokenPayload {\n\t/**\n\t * Issuer\n\t */\n\tiss?: string;\n\t/**\n\t * Subject\n\t */\n\tsub?: string;\n\t/**\n\t * Audience\n\t */\n\taud?: string;\n\t/**\n\t * Expiration Time\n\t */\n\texp: UnixTime;\n\t/**\n\t * Not Before\n\t */\n\tnbf?: UnixTime;\n\t/**\n\t * Issued at\n\t */\n\tiat?: UnixTime;\n\t/**\n\t * JWT ID\n\t */\n\tjti?: string;\n}\n\n/**\n * Common token pair\n */\nexport interface JwtTokenPair {\n\taccessToken: JwtTokenString;\n\trefreshToken: JwtTokenString;\n}\n\nexport class JwtToken<Claims = Record<string | number, unknown>> {\n\tpublic static readonly JWT_TOKEN_SEPARATOR = '.';\n\n\tpublic constructor(\n\t\tpublic header: JwtTokenHeader,\n\t\tpublic payload: JwtTokenPayload & Claims,\n\t\tpublic signature: string\n\t) {}\n\n\tpublic static from<FromClaims = Record<string | number, unknown>>(\n\t\ttoken: JwtTokenString\n\t): JwtToken<FromClaims> | null {\n\t\tconst convertedSegments = JwtToken.splitTokenString(token);\n\t\tif (!convertedSegments) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst header = decodeJsonLikeBase64<JwtTokenHeader>(convertedSegments[0]);\n\t\tconst payload = decodeJsonLikeBase64<JwtTokenPayload & FromClaims>(convertedSegments[1]);\n\t\tconst signature = Base64.decode(convertedSegments[2]); // Not used, only for validation\n\t\tif (!header || !payload || !signature) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn new JwtToken<FromClaims>(header, payload, signature);\n\t}\n\n\tpublic static stripScheme(jwtHeaderValue: string, scheme?: string): JwtTokenString {\n\t\treturn jwtHeaderValue.substring((scheme ?? '').length);\n\t}\n\n\tpublic static splitTokenString(\n\t\ttoken: JwtTokenString,\n\t\tseparator: string = JwtToken.JWT_TOKEN_SEPARATOR\n\t): [Base64String, Base64String, Base64String] | null {\n\t\tconst spl = token.split(separator);\n\t\tif (spl.length !== 3) {\n\t\t\treturn null;\n\t\t}\n\t\treturn spl as [Base64String, Base64String, Base64String];\n\t}\n\n\tpublic isExpired(): boolean {\n\t\treturn isUnixTimestampExpired(this.payload.exp);\n\t}\n}\n","import { InjectionToken } from '@angular/core';\nimport {\n\tJwtConfiguration,\n\tJwtRefreshConfiguration,\n} from '../model/auth-core-configuration.interface';\nimport { TypedProvider } from '../model/typed-providers.interface';\n\nexport const JWT_CONFIGURATION_TOKEN = new InjectionToken<JwtConfiguration>(\n\t'AegisJwtConfiguration'\n);\n\nexport const DEFAULT_JWT_CONFIGURATION_TOKEN = new InjectionToken<Partial<JwtConfiguration>>(\n\t'DefaultAegisJwtConfiguration'\n);\n\nexport const JWT_REFRESH_CONFIGURATION_TOKEN = new InjectionToken<\n\tJwtRefreshConfiguration<unknown, unknown>\n>('AegisJwtRefreshConfiguration');\n\nexport const DEFAULT_JWT_REFRESH_CONFIGURATION_TOKEN = new InjectionToken<\n\tPartial<JwtRefreshConfiguration<unknown, unknown>>\n>('DefaultAegisJwtRefreshConfiguration');\n\n/**\n * To provide an {@link AuthTokenConfiguration |  AuthTokenConfiguration}\n */\nexport type JwtConfigurationProvider<> = TypedProvider<JwtConfiguration>;\n\n/**\n * To provide an {@link AuthTokenConfiguration |  AuthTokenConfiguration}\n */\nexport type JwtRefreshConfigurationProvider<RefreshRequest, RefreshResponse> = TypedProvider<\n\tJwtRefreshConfiguration<RefreshRequest, RefreshResponse>\n>;\n\n/**\n * This type describes a providerlike object that doesn't have a provide field\n * because that will be defaulted by the\n * {@link createRefreshableAuthTokenProvider | createRefreshableAuthTokenProvider }\n * function\n */\nexport type JwtModuleConfigurationProvider = Partial<\n\tOmit<TypedProvider<Partial<JwtConfiguration>>, 'provide' | 'multi'>\n>;\n\nexport type JwtModuleRefreshConfigurationProvider<RefreshRequest, RefreshResponse> = Partial<\n\tOmit<\n\t\tTypedProvider<Partial<JwtRefreshConfiguration<RefreshRequest, RefreshResponse>>>,\n\t\t'provide' | 'multi'\n\t>\n>;\n","import { HttpHandler } from '@angular/common/http';\nimport { Inject, Injectable, Optional } from '@angular/core';\nimport { Router } from '@angular/router';\nimport { Observable, of } from 'rxjs';\nimport { catchError, map, switchMap } from 'rxjs/operators';\nimport { JwtCouldntRefreshError } from '../errors/jwt-error.class';\nimport { handleJwtError } from '../function/handle-jwt-error.function';\nimport { intoObservable } from '../function/into-observable.function';\nimport { isNotNullish } from '../function/is-not-nullish.predicate';\nimport { isUnixTimestampExpiredNowAndWhenItIs } from '../function/is-unix-timestamp-expired-now-and-when-it-is.function';\nimport { isString } from '../function/string.predicate';\nimport { tryJwtRefresh } from '../function/try-jwt-refresh.function';\nimport {\n\tJwtConfiguration,\n\tJwtRefreshConfiguration,\n} from '../model/auth-core-configuration.interface';\nimport { JwtToken } from '../model/jwt-token.class';\nimport {\n\tDEFAULT_JWT_CONFIGURATION_TOKEN,\n\tDEFAULT_JWT_REFRESH_CONFIGURATION_TOKEN,\n\tJWT_CONFIGURATION_TOKEN,\n\tJWT_REFRESH_CONFIGURATION_TOKEN,\n} from '../token/jwt-configuration.token';\n\n@Injectable({\n\tprovidedIn: 'root',\n})\nexport class JwtTokenService<\n\tClaims = Record<string | number, unknown>,\n\tRefreshClaims = Record<string | number, unknown>,\n\tRefreshRequest = Record<string | number, unknown>,\n\tRefreshResponse = Record<string | number, unknown>\n> {\n\tpublic readonly config: JwtConfiguration = {\n\t\t...this.rawDefaultConfig,\n\t\t...this.rawConfig,\n\t};\n\n\tpublic readonly refreshConfig?: JwtRefreshConfiguration<RefreshRequest, RefreshResponse> =\n\t\tthis.rawDefaultRefreshConfig && this.rawRefreshConfig\n\t\t\t? {\n\t\t\t\t\t...this.rawDefaultRefreshConfig,\n\t\t\t\t\t...this.rawRefreshConfig,\n\t\t\t  }\n\t\t\t: undefined;\n\n\t/**\n\t * Consider restricting getToken to observables only so things can be cached\n\t */\n\tpublic readonly rawAccessToken$ = intoObservable(this.config.getToken);\n\n\tpublic readonly rawRefreshToken$ = this.refreshConfig?.getRefreshToken\n\t\t? intoObservable(this.refreshConfig.getRefreshToken)\n\t\t: of(null);\n\n\tpublic readonly accessToken$ = this.rawAccessToken$.pipe(\n\t\tmap((token) => {\n\t\t\tif (isString(token)) {\n\t\t\t\tconst jwtToken = JwtToken.from<Claims>(token);\n\t\t\t\tif (!jwtToken) {\n\t\t\t\t\tthrow new Error('Non-valid token observed');\n\t\t\t\t} else {\n\t\t\t\t\treturn jwtToken;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t})\n\t);\n\n\tpublic readonly refreshToken$ = this.rawRefreshToken$.pipe(\n\t\tmap((refreshToken) => {\n\t\t\tif (isString(refreshToken)) {\n\t\t\t\tconst jwtToken = JwtToken.from<RefreshClaims>(refreshToken);\n\t\t\t\tif (!jwtToken) {\n\t\t\t\t\tthrow new Error('Non-valid token observed');\n\t\t\t\t} else {\n\t\t\t\t\treturn jwtToken;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t})\n\t);\n\n\tpublic readonly accessTokenHeader$ = this.accessToken$.pipe(\n\t\tmap((token) => token?.header ?? null)\n\t);\n\n\tpublic readonly accessTokenPayload$ = this.accessToken$.pipe(\n\t\tmap((token) => token?.payload ?? null)\n\t);\n\n\tpublic readonly refreshTokenHeader$ = this.refreshToken$.pipe(\n\t\tmap((token) => token?.header ?? null)\n\t);\n\n\tpublic readonly refreshTokenPayload$ = this.refreshToken$.pipe(\n\t\tmap((token) => token?.payload ?? null)\n\t);\n\n\tpublic readonly isAccessTokenExpired$ = this.accessToken$.pipe(\n\t\tswitchMap((token) =>\n\t\t\ttoken ? isUnixTimestampExpiredNowAndWhenItIs(token.payload.exp) : of(null)\n\t\t)\n\t);\n\n\tpublic readonly isRefreshTokenExpired$ = this.refreshToken$.pipe(\n\t\tswitchMap((token) =>\n\t\t\ttoken ? isUnixTimestampExpiredNowAndWhenItIs(token.payload.exp) : of(null)\n\t\t)\n\t);\n\n\tpublic readonly isAccessTokenValid$ = this.isAccessTokenExpired$.pipe(\n\t\tmap((isExpired) => isNotNullish(isExpired) && !isExpired)\n\t);\n\n\tpublic readonly isRefreshTokenValid$ = this.isRefreshTokenExpired$.pipe(\n\t\tmap((isExpired) => isNotNullish(isExpired) && !isExpired)\n\t);\n\n\tpublic constructor(\n\t\tprivate readonly httpHandler: HttpHandler,\n\t\t@Inject(JWT_CONFIGURATION_TOKEN)\n\t\tprivate readonly rawConfig: JwtConfiguration,\n\t\t@Inject(DEFAULT_JWT_CONFIGURATION_TOKEN)\n\t\tprivate readonly rawDefaultConfig: JwtConfiguration,\n\t\t@Inject(DEFAULT_JWT_REFRESH_CONFIGURATION_TOKEN)\n\t\t@Optional()\n\t\tprivate readonly rawDefaultRefreshConfig?: JwtRefreshConfiguration<\n\t\t\tRefreshRequest,\n\t\t\tRefreshResponse\n\t\t>,\n\t\t@Inject(JWT_REFRESH_CONFIGURATION_TOKEN)\n\t\t@Optional()\n\t\tprivate readonly rawRefreshConfig?: JwtRefreshConfiguration<\n\t\t\tRefreshRequest,\n\t\t\tRefreshResponse\n\t\t>,\n\t\t@Optional() private readonly router?: Router\n\t) {}\n\n\t/**\n\t * Does a token refresh. Emits false if it failed, or true if succeeded.\n\t */\n\tpublic manualRefresh(): Observable<boolean> {\n\t\tif (this.refreshConfig) {\n\t\t\treturn tryJwtRefresh(\n\t\t\t\tthis.httpHandler,\n\t\t\t\t'Access token not valid on guard activation',\n\t\t\t\tthis.refreshConfig,\n\t\t\t\t(refreshError) =>\n\t\t\t\t\thandleJwtError<RefreshRequest, RefreshResponse>(\n\t\t\t\t\t\tJwtCouldntRefreshError.createErrorResponse(undefined, refreshError),\n\t\t\t\t\t\tthis.config,\n\t\t\t\t\t\tthis.refreshConfig,\n\t\t\t\t\t\tthis.router\n\t\t\t\t\t).pipe(catchError(() => of(false))),\n\t\t\t\t() => of(true)\n\t\t\t);\n\t\t} else {\n\t\t\treturn of(false);\n\t\t}\n\t}\n}\n","import { Injectable } from '@angular/core';\nimport {\n\tActivatedRouteSnapshot,\n\tCanActivate,\n\tCanActivateChild,\n\tCanLoad,\n\tRoute,\n\tRouterStateSnapshot,\n\tUrlSegment,\n\tUrlTree,\n} from '@angular/router';\nimport { Observable, of } from 'rxjs';\nimport { switchMap, take } from 'rxjs/operators';\nimport { DEFAULT_JWT_REFRESH_CONFIG_DEFAULT_AUTO_IN_GUARD } from '../model/auth-core-configuration.interface';\nimport { JwtTokenService } from '../service/jwt-token.service';\n\n/**\n * This interface is for your convinience to use with Route data to see what\n * you can configure on the LoginGuard\n */\nexport interface LoginGuardData {\n\t/**\n\t * Explicitly enable or disable auto refreshing on the route.\n\t */\n\tisRefreshAllowed: boolean;\n}\n\n@Injectable({\n\tprovidedIn: 'root',\n})\nexport class LoginGuard implements CanActivate, CanActivateChild, CanLoad {\n\tprivate isAccessTokenValidOnce$ = this.jwtTokenService.isAccessTokenValid$.pipe(take(1));\n\n\tpublic constructor(private readonly jwtTokenService: JwtTokenService) {}\n\n\tpublic canActivate(\n\t\troute: ActivatedRouteSnapshot,\n\t\t_state: RouterStateSnapshot\n\t): Observable<boolean | UrlTree> | Promise<boolean | UrlTree> | boolean | UrlTree {\n\t\tconst data = route.data as LoginGuardData | undefined;\n\t\treturn this.isValid(data?.isRefreshAllowed);\n\t}\n\n\tpublic canActivateChild(\n\t\tchildRoute: ActivatedRouteSnapshot,\n\t\t_state: RouterStateSnapshot\n\t): Observable<boolean | UrlTree> | Promise<boolean | UrlTree> | boolean | UrlTree {\n\t\tconst data = childRoute.data as LoginGuardData | undefined;\n\t\treturn this.isValid(data?.isRefreshAllowed);\n\t}\n\n\tpublic canLoad(\n\t\troute: Route,\n\t\t_segments: UrlSegment[]\n\t): Observable<boolean> | Promise<boolean> | boolean {\n\t\tconst data = route.data as LoginGuardData | undefined;\n\t\treturn this.isValid(data?.isRefreshAllowed);\n\t}\n\n\tprivate isValid(isRefreshAllowed: boolean | undefined): Observable<boolean> {\n\t\tconst allowed =\n\t\t\tisRefreshAllowed ??\n\t\t\tthis.jwtTokenService.refreshConfig?.isAutoRefreshAllowedInLoginGuardByDefault ??\n\t\t\tDEFAULT_JWT_REFRESH_CONFIG_DEFAULT_AUTO_IN_GUARD;\n\t\treturn this.isAccessTokenValidOnce$.pipe(\n\t\t\tswitchMap((isValid) => {\n\t\t\t\tif (!isValid && allowed) {\n\t\t\t\t\treturn this.jwtTokenService.manualRefresh();\n\t\t\t\t} else {\n\t\t\t\t\treturn of(isValid);\n\t\t\t\t}\n\t\t\t})\n\t\t);\n\t}\n}\n","import {\n\tHttpErrorResponse,\n\tHttpEvent,\n\tHttpHandler,\n\tHttpInterceptor,\n\tHttpRequest,\n} from '@angular/common/http';\nimport { Inject, Injectable, Optional } from '@angular/core';\nimport { Router } from '@angular/router';\nimport { Observable } from 'rxjs';\nimport { catchError } from 'rxjs/operators';\nimport { handleJwtError } from '../function/handle-jwt-error.function';\nimport {\n\tJwtConfiguration,\n\tJwtRefreshConfiguration,\n} from '../model/auth-core-configuration.interface';\nimport {\n\tDEFAULT_JWT_CONFIGURATION_TOKEN,\n\tDEFAULT_JWT_REFRESH_CONFIGURATION_TOKEN,\n\tJWT_CONFIGURATION_TOKEN,\n\tJWT_REFRESH_CONFIGURATION_TOKEN,\n} from '../token/jwt-configuration.token';\n\n/**\n * If configured, handles authentication errors with custom callbacks\n * or redirects\n */\n@Injectable()\nexport class JwtErrorHandlingInterceptor implements HttpInterceptor {\n\tprivate readonly jwtConfiguration: JwtConfiguration;\n\tprivate readonly jwtRefreshConfiguration?: JwtRefreshConfiguration<unknown, unknown>;\n\tpublic constructor(\n\t\t@Inject(JWT_CONFIGURATION_TOKEN)\n\t\tjwtConfig: JwtConfiguration,\n\t\t@Inject(DEFAULT_JWT_CONFIGURATION_TOKEN)\n\t\tdefaultJwtConfig: JwtConfiguration,\n\t\t@Optional()\n\t\t@Inject(JWT_REFRESH_CONFIGURATION_TOKEN)\n\t\trefreshConfig?: JwtRefreshConfiguration<unknown, unknown>,\n\t\t@Optional()\n\t\t@Inject(DEFAULT_JWT_REFRESH_CONFIGURATION_TOKEN)\n\t\tdefaultJwtRefreshConfig?: JwtRefreshConfiguration<unknown, unknown>,\n\t\t@Optional() private readonly router?: Router\n\t) {\n\t\tthis.jwtConfiguration = {\n\t\t\t...defaultJwtConfig,\n\t\t\t...jwtConfig,\n\t\t};\n\n\t\tthis.jwtRefreshConfiguration =\n\t\t\tdefaultJwtRefreshConfig && refreshConfig\n\t\t\t\t? {\n\t\t\t\t\t\t...defaultJwtRefreshConfig,\n\t\t\t\t\t\t...refreshConfig,\n\t\t\t\t  }\n\t\t\t\t: undefined;\n\t}\n\tpublic intercept(\n\t\trequest: HttpRequest<unknown>,\n\t\tnext: HttpHandler\n\t): Observable<HttpEvent<unknown>> {\n\t\treturn next\n\t\t\t.handle(request)\n\t\t\t.pipe(\n\t\t\t\tcatchError((errorResponse: HttpErrorResponse) =>\n\t\t\t\t\thandleJwtError(\n\t\t\t\t\t\terrorResponse,\n\t\t\t\t\t\tthis.jwtConfiguration,\n\t\t\t\t\t\tthis.jwtRefreshConfiguration,\n\t\t\t\t\t\tthis.router\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t);\n\t}\n}\n","import { isString } from './string.predicate';\n\nexport const matchRule = (rule: string | RegExp, against?: string | null): boolean => {\n\tif (isString(rule)) {\n\t\treturn rule === against;\n\t} else if (against) {\n\t\treturn rule.test(against);\n\t} else {\n\t\treturn false;\n\t}\n};\n\n/**\n *\n * @param inverse easy negating when composing\n */\nexport const matchAgainst = (against?: string | null, inverse = false) => (\n\trule: string | RegExp\n): boolean => (inverse ? !matchRule(rule, against) : matchRule(rule, against));\n","import { UrlFilter } from '../model/header-configuration.interface';\nimport { matchAgainst } from './match-against.function';\nimport { SeparatedUrl } from './separate-url.function';\n\n/**\n * Matches the filter against a separated url. Non-existend rulesets\n * automatically pass. **Empty whitelist rulesets never pass.** Empty blacklist\n * rulesets always pass.\n */\nexport const checkAgainstUrlFilter = (\n\turlFilter: UrlFilter,\n\t{ domain, path, protocol }: SeparatedUrl\n): boolean => {\n\tconst protocolMatcher = matchAgainst(protocol);\n\tconst domainMatcher = matchAgainst(domain);\n\tconst pathMatcher = matchAgainst(path);\n\n\tconst protocolWhitelistRulesPass = urlFilter.protocolWhitelist?.some(protocolMatcher) ?? true;\n\n\tconst protocolBlacklistRulesPass = !urlFilter.protocolBlacklist?.some(protocolMatcher);\n\n\tconst domainWhitelistRulesPass = urlFilter.domainWhitelist?.some(domainMatcher) ?? true;\n\n\tconst domainBlacklistRulesPass = !urlFilter.domainBlacklist?.some(domainMatcher);\n\n\tconst pathWhitelistRulesPass = urlFilter.pathWhitelist?.some(pathMatcher) ?? true;\n\n\tconst pathBlacklistRulesPass = !urlFilter.pathBlacklist?.some(pathMatcher);\n\n\treturn (\n\t\tprotocolWhitelistRulesPass &&\n\t\tprotocolBlacklistRulesPass &&\n\t\tdomainWhitelistRulesPass &&\n\t\tdomainBlacklistRulesPass &&\n\t\tpathWhitelistRulesPass &&\n\t\tpathBlacklistRulesPass\n\t);\n};\n","export type UrlProtocol = string;\nexport type UrlDomain = string;\nexport type UrlPath = string;\n\n/**\n * An url separated into optional parts, the separators are not included.\n * Separator between protocol and domain is `://`, and between domain\n * and path is `/`.\n */\nexport interface SeparatedUrl {\n\t/**\n\t * @example `http`\n\t */\n\tprotocol?: UrlProtocol;\n\n\t/**\n\t * @example `localhost`\n\t */\n\tdomain?: UrlDomain;\n\n\t/**\n\t * @example `foo/bar`\n\t */\n\tpath?: UrlPath;\n}\n\n/**\n * Returns the url split into parts, without the separators.\n * Separator between protocol and domain is `://`, and between domain\n * and path is `/`.\n */\nexport const separateUrl = (url?: string): SeparatedUrl => {\n\tconst urlMatch = url?.match(/^((.*):\\/\\/)?([^/].*?)?(\\/(.*))?$/);\n\treturn {\n\t\tprotocol: urlMatch?.[2] as UrlProtocol,\n\t\tdomain: urlMatch?.[3] as UrlDomain,\n\t\tpath: urlMatch?.[5] as UrlPath,\n\t};\n};\n","import { HttpEvent, HttpHandler, HttpInterceptor, HttpRequest } from '@angular/common/http';\nimport { Inject, Injectable, Optional } from '@angular/core';\nimport { Observable, throwError } from 'rxjs';\nimport { switchMap, take } from 'rxjs/operators';\nimport { JwtError } from '../errors/jwt-error.class';\nimport { checkAgainstUrlFilter } from '../function/check-against-url-filter.function';\nimport { intoObservable } from '../function/into-observable.function';\nimport { separateUrl } from '../function/separate-url.function';\nimport {\n\tJwtConfiguration,\n\tJwtRefreshConfiguration,\n} from '../model/auth-core-configuration.interface';\nimport { JwtToken } from '../model/jwt-token.class';\nimport {\n\tDEFAULT_JWT_CONFIGURATION_TOKEN,\n\tDEFAULT_JWT_REFRESH_CONFIGURATION_TOKEN,\n\tJWT_CONFIGURATION_TOKEN,\n\tJWT_REFRESH_CONFIGURATION_TOKEN,\n} from '../token/jwt-configuration.token';\n\n@Injectable()\nexport class JwtInjectorInterceptor implements HttpInterceptor {\n\tprivate readonly jwtConfiguration!: JwtConfiguration;\n\tprivate readonly jwtRefreshConfiguration?: JwtRefreshConfiguration<unknown, unknown>;\n\n\tpublic constructor(\n\t\t@Inject(JWT_CONFIGURATION_TOKEN)\n\t\tjwtConfig: JwtConfiguration,\n\t\t@Inject(DEFAULT_JWT_CONFIGURATION_TOKEN)\n\t\tdefaultJwtConfig: JwtConfiguration,\n\t\t@Optional()\n\t\t@Inject(JWT_REFRESH_CONFIGURATION_TOKEN)\n\t\trefreshConfig?: JwtRefreshConfiguration<unknown, unknown>,\n\t\t@Optional()\n\t\t@Inject(DEFAULT_JWT_REFRESH_CONFIGURATION_TOKEN)\n\t\tdefaultJwtRefreshConfig?: JwtRefreshConfiguration<unknown, unknown>\n\t) {\n\t\tthis.jwtConfiguration = {\n\t\t\t...defaultJwtConfig,\n\t\t\t...jwtConfig,\n\t\t};\n\n\t\tthis.jwtRefreshConfiguration = refreshConfig &&\n\t\t\tdefaultJwtRefreshConfig && {\n\t\t\t\t...defaultJwtRefreshConfig,\n\t\t\t\t...refreshConfig,\n\t\t\t};\n\t}\n\n\tpublic intercept(\n\t\trequest: HttpRequest<unknown>,\n\t\tnext: HttpHandler\n\t): Observable<HttpEvent<unknown>> {\n\t\tconst separatedUrl = separateUrl(request.url);\n\t\treturn intoObservable(this.jwtConfiguration.getToken).pipe(\n\t\t\ttake(1),\n\t\t\tswitchMap((rawToken) => {\n\t\t\t\tif (checkAgainstUrlFilter(this.jwtConfiguration, separatedUrl)) {\n\t\t\t\t\tconst token = rawToken && JwtToken.from(rawToken);\n\t\t\t\t\tconst isAccessTokenExpiredOrInvalid = !token || token.isExpired();\n\t\t\t\t\t// If there is a token to inject\n\t\t\t\t\tif (\n\t\t\t\t\t\trawToken &&\n\t\t\t\t\t\t(!isAccessTokenExpiredOrInvalid || this.jwtRefreshConfiguration)\n\t\t\t\t\t) {\n\t\t\t\t\t\tlet cloned = request.clone({\n\t\t\t\t\t\t\theaders: request.headers.set(\n\t\t\t\t\t\t\t\tthis.jwtConfiguration.header,\n\t\t\t\t\t\t\t\tthis.jwtConfiguration.scheme\n\t\t\t\t\t\t\t\t\t? this.jwtConfiguration.scheme + rawToken\n\t\t\t\t\t\t\t\t\t: rawToken\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t});\n\t\t\t\t\t\tif (this.jwtConfiguration.handleWithCredentials) {\n\t\t\t\t\t\t\tcloned = cloned.clone({\n\t\t\t\t\t\t\t\twithCredentials: true,\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn next.handle(cloned);\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn throwError(\n\t\t\t\t\t\t\tJwtError.createErrorResponse(\n\t\t\t\t\t\t\t\trequest,\n\t\t\t\t\t\t\t\t'Token is expired or invalid, and refresh is not configured.'\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\treturn next.handle(request);\n\t\t\t\t}\n\t\t\t})\n\t\t);\n\t}\n}\n","import {\n\tHttpErrorResponse,\n\tHttpEvent,\n\tHttpHandler,\n\tHttpInterceptor,\n\tHttpRequest,\n} from '@angular/common/http';\nimport { Inject, Injectable } from '@angular/core';\nimport { Observable, throwError } from 'rxjs';\nimport { catchError, switchMap, take } from 'rxjs/operators';\nimport { JwtCannotRefreshError, JwtCouldntRefreshError } from '../errors/jwt-error.class';\nimport { checkAgainstUrlFilter } from '../function/check-against-url-filter.function';\nimport { intoObservable } from '../function/into-observable.function';\nimport { matchAgainst } from '../function/match-against.function';\nimport { separateUrl } from '../function/separate-url.function';\nimport { tryJwtRefresh } from '../function/try-jwt-refresh.function';\nimport {\n\tJwtConfiguration,\n\tJwtRefreshConfiguration,\n} from '../model/auth-core-configuration.interface';\nimport { JwtToken } from '../model/jwt-token.class';\nimport {\n\tDEFAULT_JWT_CONFIGURATION_TOKEN,\n\tDEFAULT_JWT_REFRESH_CONFIGURATION_TOKEN,\n\tJWT_CONFIGURATION_TOKEN,\n\tJWT_REFRESH_CONFIGURATION_TOKEN,\n} from '../token/jwt-configuration.token';\n\n@Injectable()\nexport class JwtRefreshInterceptor implements HttpInterceptor {\n\tprivate readonly jwtConfiguration!: JwtConfiguration;\n\tprivate readonly jwtRefreshConfiguration!: JwtRefreshConfiguration<unknown, unknown>;\n\tprivate readonly rawRefreshToken$: Observable<string | null | undefined>;\n\tprivate readonly isRawRefreshTokenGetterAvailable: boolean;\n\n\tpublic constructor(\n\t\t@Inject(JWT_CONFIGURATION_TOKEN)\n\t\tjwtConfig: JwtConfiguration,\n\t\t@Inject(DEFAULT_JWT_CONFIGURATION_TOKEN)\n\t\tdefaultJwtConfig: JwtConfiguration,\n\t\t@Inject(JWT_REFRESH_CONFIGURATION_TOKEN)\n\t\trefreshConfig: JwtRefreshConfiguration<unknown, unknown>,\n\t\t@Inject(DEFAULT_JWT_REFRESH_CONFIGURATION_TOKEN)\n\t\tdefaultJwtRefreshConfig: JwtRefreshConfiguration<unknown, unknown>\n\t) {\n\t\tthis.jwtConfiguration = {\n\t\t\t...defaultJwtConfig,\n\t\t\t...jwtConfig,\n\t\t};\n\n\t\tthis.jwtRefreshConfiguration = {\n\t\t\t...defaultJwtRefreshConfig,\n\t\t\t...refreshConfig,\n\t\t};\n\n\t\tthis.rawRefreshToken$ = intoObservable(\n\t\t\tthis.jwtRefreshConfiguration.getRefreshToken ?? (() => null)\n\t\t);\n\n\t\tthis.isRawRefreshTokenGetterAvailable = !!this.jwtRefreshConfiguration.getRefreshToken;\n\t}\n\n\tpublic intercept(\n\t\trequest: HttpRequest<unknown>,\n\t\tnext: HttpHandler\n\t): Observable<HttpEvent<unknown>> {\n\t\tconst separatedUrl = separateUrl(request.url);\n\t\tconst jwtHeaderValue = request.headers.get(this.jwtConfiguration.header);\n\n\t\t// Only do something if the request is headed towards a protected endpoint.\n\t\t// The forRoot method of the module ensures that this interceptor is injected\n\t\t// after the token injector interceptor. So by the time this executes, the token should\n\t\t// be here.\n\t\t// And if the url is not the refresh url itself, and any of the other explicitly\n\t\t// filtered urls where refresh is prohibited by config.\n\t\tif (\n\t\t\tjwtHeaderValue &&\n\t\t\t!matchAgainst(request.url)(this.jwtRefreshConfiguration.refreshUrl) &&\n\t\t\tcheckAgainstUrlFilter(this.jwtRefreshConfiguration, separatedUrl)\n\t\t) {\n\t\t\treturn this.rawRefreshToken$.pipe(\n\t\t\t\ttake(1),\n\t\t\t\tswitchMap((rawRefreshToken) => {\n\t\t\t\t\tconst rawToken = JwtToken.stripScheme(\n\t\t\t\t\t\tjwtHeaderValue,\n\t\t\t\t\t\tthis.jwtConfiguration.scheme\n\t\t\t\t\t);\n\t\t\t\t\tconst token = JwtToken.from(rawToken);\n\t\t\t\t\tconst refreshToken = rawRefreshToken ? JwtToken.from(rawRefreshToken) : null;\n\t\t\t\t\tconst isAccessTokenExpiredOrInvalid = !token || token.isExpired();\n\t\t\t\t\tconst isRefreshTokenExpiredOrInvalid =\n\t\t\t\t\t\t!refreshToken || refreshToken.isExpired();\n\t\t\t\t\t// If we know beforehand that nothing can be done, panic.\n\t\t\t\t\tif (\n\t\t\t\t\t\tisAccessTokenExpiredOrInvalid &&\n\t\t\t\t\t\tthis.isRawRefreshTokenGetterAvailable &&\n\t\t\t\t\t\tisRefreshTokenExpiredOrInvalid\n\t\t\t\t\t) {\n\t\t\t\t\t\treturn throwError(\n\t\t\t\t\t\t\tJwtCannotRefreshError.createErrorResponse(\n\t\t\t\t\t\t\t\trequest,\n\t\t\t\t\t\t\t\t'Both access and refresh tokens are expired'\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\t// If the conversion would fail, that would handle the same as an expired token\n\t\t\t\t\treturn (isAccessTokenExpiredOrInvalid\n\t\t\t\t\t\t? // If the token is used and is expired, don't even try the request.\n\t\t\t\t\t\t  throwError('Expired token, refresh first')\n\t\t\t\t\t\t: // If it seems okay, try the request\n\t\t\t\t\t\t  next.handle(request)\n\t\t\t\t\t).pipe(\n\t\t\t\t\t\tcatchError((error: HttpErrorResponse | string) =>\n\t\t\t\t\t\t\t// If the request failed, or we failed at the precheck\n\t\t\t\t\t\t\t// Acquire a new token, but only if the error is allowing it\n\n\t\t\t\t\t\t\ttryJwtRefresh(\n\t\t\t\t\t\t\t\tnext,\n\t\t\t\t\t\t\t\terror,\n\t\t\t\t\t\t\t\tthis.jwtRefreshConfiguration,\n\t\t\t\t\t\t\t\t(refreshError) =>\n\t\t\t\t\t\t\t\t\tthrowError(\n\t\t\t\t\t\t\t\t\t\tJwtCouldntRefreshError.createErrorResponse(\n\t\t\t\t\t\t\t\t\t\t\trequest,\n\t\t\t\t\t\t\t\t\t\t\trefreshError\n\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\t(refreshResponse) => {\n\t\t\t\t\t\t\t\t\tconst requestWithUpdatedTokens = request.clone({\n\t\t\t\t\t\t\t\t\t\theaders: request.headers.set(\n\t\t\t\t\t\t\t\t\t\t\tthis.jwtConfiguration.header,\n\t\t\t\t\t\t\t\t\t\t\tthis.jwtConfiguration.scheme +\n\t\t\t\t\t\t\t\t\t\t\t\trefreshResponse.accessToken\n\t\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\treturn next.handle(requestWithUpdatedTokens);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t)\n\t\t\t\t\t);\n\t\t\t\t})\n\t\t\t);\n\t\t} else {\n\t\t\treturn next.handle(request);\n\t\t}\n\t}\n}\n","import {\n\tJwtConfigurationProvider,\n\tJwtModuleConfigurationProvider,\n\tJWT_CONFIGURATION_TOKEN,\n} from '../token/jwt-configuration.token';\n\n/**\n * Helps you define a JwtConfigurationProvider\n *\n * @internal\n */\nexport const createJwtConfigurationProvider = (\n\ttokenConfigurationProvider: JwtModuleConfigurationProvider\n): JwtConfigurationProvider =>\n\t({\n\t\tprovide: JWT_CONFIGURATION_TOKEN,\n\t\tmulti: false,\n\t\t...tokenConfigurationProvider,\n\t} as JwtConfigurationProvider);\n","import {\n\tJwtModuleRefreshConfigurationProvider,\n\tJwtRefreshConfigurationProvider,\n\tJWT_REFRESH_CONFIGURATION_TOKEN,\n} from '../token/jwt-configuration.token';\n\n/**\n * Helps you define a JwtConfigurationProvider\n *\n * @internal\n */\nexport const createJwtRefreshConfigurationProvider = <RefreshRequest, RefreshResponse>(\n\ttokenRefreshConfigurationProvider: JwtModuleRefreshConfigurationProvider<\n\t\tRefreshRequest,\n\t\tRefreshResponse\n\t>\n): JwtRefreshConfigurationProvider<RefreshRequest, RefreshResponse> =>\n\t({\n\t\tprovide: JWT_REFRESH_CONFIGURATION_TOKEN,\n\t\tmulti: false,\n\t\t...tokenRefreshConfigurationProvider,\n\t} as JwtRefreshConfigurationProvider<RefreshRequest, RefreshResponse>);\n","import { CommonModule } from '@angular/common';\nimport { HTTP_INTERCEPTORS } from '@angular/common/http';\nimport { ModuleWithProviders, NgModule } from '@angular/core';\nimport { JwtErrorHandlingInterceptor } from './interceptor/jwt-error-handling.interceptor';\nimport { JwtInjectorInterceptor } from './interceptor/jwt-injector.interceptor';\nimport { JwtRefreshInterceptor } from './interceptor/jwt-refresh.interceptor';\nimport {\n\tDEFAULT_JWT_CONFIG,\n\tDEFAULT_JWT_REFRESH_CONFIG,\n} from './model/auth-core-configuration.interface';\nimport { createJwtConfigurationProvider } from './providers/create-jwt-configuration-provider.function';\nimport { createJwtRefreshConfigurationProvider } from './providers/create-jwt-refresh-configuration-provider.function';\nimport {\n\tDEFAULT_JWT_CONFIGURATION_TOKEN,\n\tDEFAULT_JWT_REFRESH_CONFIGURATION_TOKEN,\n\tJwtModuleConfigurationProvider,\n\tJwtModuleRefreshConfigurationProvider,\n} from './token/jwt-configuration.token';\n\n/**\n * This module needs to be configured to use. See the\n * {@link JwtModule#forRoot | forRoot} method for more information.\n *\n * tokens. So that other, plug in configration modules can provide them.\n * Like Ngrx and Local. They then transform their configs into this common one.\n */\n@NgModule({\n\timports: [CommonModule],\n})\nexport class JwtModule {\n\t/**\n\t * To define the interceptors and the token with the provided config.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * (a)NgModule({\n\t *\t\timports: [\n\t *\t\t\tJwtModule.forRoot<Foo>({\n\t *\t\t\t\t\tuseFactory: (foo) => foo.getConf(),\n\t *\t\t\t\t\tdeps: [Foo] // if something has to be injected\n\t *\t\t\t})\n\t *\t\t]\n\t *\t})\n\t *\texport class CoreModule {}\n\t * ```\n\t * @param tokenProvider create with `createAuthTokenProvider` or\n\t * \t`createRefreshableAuthTokenProvider`\n\t */\n\tpublic static forRoot(\n\t\tjwtModuleConfigurationProvider: JwtModuleConfigurationProvider\n\t): ModuleWithProviders<JwtModule>;\n\tpublic static forRoot<RefreshRequest, RefreshResponse>(\n\t\tjwtModuleConfigurationProvider: JwtModuleConfigurationProvider,\n\t\tjwtRefreshConfigurationProvider: JwtModuleRefreshConfigurationProvider<\n\t\t\tRefreshRequest,\n\t\t\tRefreshResponse\n\t\t>\n\t): ModuleWithProviders<JwtModule>;\n\tpublic static forRoot<RefreshRequest, RefreshResponse>(\n\t\tjwtModuleConfigurationProvider: JwtModuleConfigurationProvider,\n\t\tjwtRefreshConfigurationProvider?: JwtModuleRefreshConfigurationProvider<\n\t\t\tRefreshRequest,\n\t\t\tRefreshResponse\n\t\t>\n\t): ModuleWithProviders<JwtModule> {\n\t\treturn {\n\t\t\tngModule: JwtModule,\n\t\t\tproviders: [\n\t\t\t\t{\n\t\t\t\t\tprovide: HTTP_INTERCEPTORS,\n\t\t\t\t\tuseClass: JwtErrorHandlingInterceptor,\n\t\t\t\t\tmulti: true,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tprovide: HTTP_INTERCEPTORS,\n\t\t\t\t\tuseClass: JwtInjectorInterceptor,\n\t\t\t\t\tmulti: true,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tprovide: DEFAULT_JWT_CONFIGURATION_TOKEN,\n\t\t\t\t\tuseValue: DEFAULT_JWT_CONFIG,\n\t\t\t\t},\n\t\t\t\tcreateJwtConfigurationProvider(jwtModuleConfigurationProvider),\n\t\t\t\t...(jwtRefreshConfigurationProvider\n\t\t\t\t\t? [\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tprovide: HTTP_INTERCEPTORS,\n\t\t\t\t\t\t\t\tuseClass: JwtRefreshInterceptor,\n\t\t\t\t\t\t\t\tmulti: true,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tprovide: DEFAULT_JWT_REFRESH_CONFIGURATION_TOKEN,\n\t\t\t\t\t\t\t\tuseValue: DEFAULT_JWT_REFRESH_CONFIG,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tcreateJwtRefreshConfigurationProvider<RefreshRequest, RefreshResponse>(\n\t\t\t\t\t\t\t\tjwtRefreshConfigurationProvider\n\t\t\t\t\t\t\t),\n\t\t\t\t\t  ]\n\t\t\t\t\t: []),\n\t\t\t],\n\t\t};\n\t}\n}\n","// eslint-disable-next-line no-shadow\nexport enum HttpMethod {\n\tGET = 'GET',\n\tHEAD = 'HEAD',\n\tPOST = 'POST',\n\tPUT = 'PUT',\n\tDELETE = 'DELETE',\n\tCONNECT = 'CONNECT',\n\tOPTIONS = 'OPTIONS',\n\tTRACE = 'TRACE',\n\tPATCH = 'PATCH',\n}\n\nexport type HttpMethodType =\n\t| 'GET'\n\t| 'HEAD'\n\t| 'POST'\n\t| 'PUT'\n\t| 'DELETE'\n\t| 'CONNECT'\n\t| 'OPTIONS'\n\t| 'TRACE'\n\t| 'PATCH';\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './index';\n\nexport {JwtErrorHandlingInterceptor as ɵe} from './lib/interceptor/jwt-error-handling.interceptor';\nexport {JwtInjectorInterceptor as ɵf} from './lib/interceptor/jwt-injector.interceptor';\nexport {JwtRefreshInterceptor as ɵg} from './lib/interceptor/jwt-refresh.interceptor';\nexport {DEFAULT_JWT_CONFIGURATION_TOKEN as ɵb,DEFAULT_JWT_REFRESH_CONFIGURATION_TOKEN as ɵd,JWT_CONFIGURATION_TOKEN as ɵa,JWT_REFRESH_CONFIGURATION_TOKEN as ɵc} from './lib/token/jwt-configuration.token';"],"names":[],"mappings":"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"}