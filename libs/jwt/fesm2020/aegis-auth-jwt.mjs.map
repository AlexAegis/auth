{"version":3,"file":"aegis-auth-jwt.mjs","sources":["../../../../libs/jwt/src/lib/function/is-unix-timestamp-expired.function.ts","../../../../libs/jwt/src/lib/model/header-configuration.interface.ts","../../../../libs/jwt/src/lib/model/auth-core-configuration.interface.ts","../../../../libs/jwt/src/lib/errors/jwt-error.class.ts","../../../../libs/jwt/src/lib/function/string.predicate.ts","../../../../libs/jwt/src/lib/function/handle-jwt-failure.function.ts","../../../../libs/jwt/src/lib/function/is-not-nullish.predicate.ts","../../../../libs/jwt/src/lib/function/handle-jwt-error.function.ts","../../../../libs/jwt/src/lib/function/function.predicate.ts","../../../../libs/jwt/src/lib/function/promise.predicate.ts","../../../../libs/jwt/src/lib/function/into-observable.function.ts","../../../../libs/jwt/src/lib/function/is-timestamp-expired-now-and-when-it-is.function.ts","../../../../libs/jwt/src/lib/function/is-unix-timestamp-expired-now-and-when-it-is.function.ts","../../../../libs/jwt/src/lib/function/check-against-http-error-filter.function.ts","../../../../libs/jwt/src/lib/function/call-when-function.function.ts","../../../../libs/jwt/src/lib/function/http-response.predicate.ts","../../../../libs/jwt/src/lib/function/do-jwt-refresh.function.ts","../../../../libs/jwt/src/lib/function/try-jwt-refresh.function.ts","../../../../libs/jwt/src/lib/function/base64-decoder.function.ts","../../../../libs/jwt/src/lib/model/jwt-token.class.ts","../../../../libs/jwt/src/lib/token/jwt-configuration.token.ts","../../../../libs/jwt/src/lib/service/jwt-refresh-state.service.ts","../../../../libs/jwt/src/lib/service/jwt-token.service.ts","../../../../libs/jwt/src/lib/guards/login.guard.ts","../../../../libs/jwt/src/lib/interceptor/jwt-error-handling.interceptor.ts","../../../../libs/jwt/src/lib/function/match-against.function.ts","../../../../libs/jwt/src/lib/function/check-against-url-filter.function.ts","../../../../libs/jwt/src/lib/function/separate-url.function.ts","../../../../libs/jwt/src/lib/interceptor/jwt-injector.interceptor.ts","../../../../libs/jwt/src/lib/interceptor/jwt-refresh.interceptor.ts","../../../../libs/jwt/src/lib/providers/create-jwt-configuration-provider.function.ts","../../../../libs/jwt/src/lib/providers/create-jwt-refresh-configuration-provider.function.ts","../../../../libs/jwt/src/lib/jwt.module.ts","../../../../libs/jwt/src/lib/model/http-method.enum.ts","../../../../libs/jwt/src/aegis-auth-jwt.ts"],"sourcesContent":["/**\n *\n * @param unixTimestamp seconds from the unix epoch 1970-01-01T00:00:00Z\n * if not supplied it will always be expired\n */\nexport const isUnixTimestampExpired = (unixTimestamp = -Infinity): boolean =>\n\tunixTimestamp < Math.floor(new Date().getTime() / 1000);\n","import { BehaviorSubject, Observable } from 'rxjs';\n\nexport const DEFAULT_HEADER_CONFIG: Partial<HeaderConfiguration> = {\n\tgetValue: new BehaviorSubject<string | null | undefined>(null),\n};\n\nexport interface NormalizedHeaderConfiguration extends HeaderConfiguration {\n\tvalue$: Observable<string | null | undefined>;\n}\n\n/**\n * Token injection configuration\n *\n * The optional generic defined the refresh endpoints Response type. If you\n * are not using that feature there's no need to define it.\n *\n * Example configuration:\n * ```typescript\n * AuthCoreModule.forRoot<TokenStorageService>({\n *\t\tuseFactory: (service: TokenStorageService) => ({\n *\t\t\tgetToken: service.accessToken$\n *\t\t\tautoRefresher: {\n * \t\t\t\tendpoint: `${environment.api}/auth/refresh`,\n * \t\t\t\tsetToken: (response) => service.accessToken$.next(response.accessToken)\n * \t\t\t}\n *\t\t}),\n *\t\tdeps: [TokenStorageService],\n * })\n * ```\n */\nexport interface HeaderConfiguration extends UrlFilter {\n\t/**\n\t * A callback or observable that will be called or subscribed to\n\t * on every http request and returns a value for the header\n\t *\n\t * @example getValue: () => localstorage.get('foo')\n\t * @example getValue: myTokenService.foo$\n\t */\n\tgetValue:\n\t\t| Observable<string | null | undefined>\n\t\t| (() =>\n\t\t\t\t| string\n\t\t\t\t| null\n\t\t\t\t| undefined\n\t\t\t\t| Promise<string | null | undefined>\n\t\t\t\t| Observable<string | null | undefined>);\n\n\t/**\n\t * Header name to be set\n\t */\n\theader: string;\n}\n\nexport interface UrlFilter {\n\t/**\n\t * These domains won't recieve this header even if they are listed in the\n\t * whitelist.\n\t *\n\t * If `null` or `undefined`, this category of rules won't take any effect.\n\t * If empty, it would mean \"No domains are blacklisted\", and it won't\n\t * take any effect.\n\t *\n\t * @default undefined\n\t * @example ['localhost:3333']\n\t * @example [/localhost:[0-9]{4}/]\n\t */\n\tdomainBlacklist?: (string | RegExp)[];\n\n\t/**\n\t * Only domains listed will be recieving header injections\n\t *\n\t * If `null` or `undefined`, this category of rules won't take any effect.\n\t * If empty, it would mean \"No domains are whitelisted\", so no paths would\n\t * recieve tokens!\n\t *\n\t * @default undefined\n\t * @example ['localhost:3333']\n\t * @example [/localhost:[0-9]{4}/]\n\t */\n\tdomainWhitelist?: (string | RegExp)[];\n\n\t/**\n\t * These paths won't recieve this header even if they are listed in the\n\t * whitelist.\n\t *\n\t * If `null` or `undefined`, this category of rules won't take any effect.\n\t * If empty, it would mean \"No paths are blacklisted\", and it won't\n\t * take any effect.\n\t *\n\t * @default undefined\n\t * @example ['api/v2/users/1']\n\t * @example [/users\\/.+/]\n\t */\n\tpathBlacklist?: (string | RegExp)[];\n\n\t/**\n\t * Only paths listed will be recieving this header injection.\n\t *\n\t * If `null` or `undefined`, this category of rules won't take any effect.\n\t * If empty, it would mean \"No paths are whitelisted\", so no paths would\n\t * recieve tokens!\n\t *\n\t * @default undefined\n\t * @example ['api/v2/users/1']\n\t * @example [/users\\/.+/]\n\t */\n\tpathWhitelist?: (string | RegExp)[];\n\n\t/**\n\t * These protocols won't recieve this header even if they are listed in\n\t * the whitelist.\n\t *\n\t * If `null` or `undefined`, this category of rules won't take any effect.\n\t * If empty, it would mean \"No protocols are blacklisted\", and it won't\n\t * take any effect.\n\t *\n\t * @default undefined\n\t * @example ['http']\n\t * @example [/https?/]\n\t */\n\tprotocolBlacklist?: (string | RegExp)[];\n\n\t/**\n\t * Only protocols listed will be recieving this header injections.\n\t *\n\t * If empty or undefined, this category of rules won't take any effect.\n\t * If empty, it would mean \"No protocols are whitelisted\", so no protocols\n\t * would recieve tokens!\n\t *\n\t * @default undefined\n\t * @example ['http']\n\t * @example [/https?/]\n\t */\n\tprotocolWhitelist?: (string | RegExp)[];\n}\n","import { HttpHeaders, HttpParams } from '@angular/common/http';\nimport { Params } from '@angular/router';\nimport { Observable } from 'rxjs';\nimport { JwtCannotRefreshError, JwtCouldntRefreshError, JwtError } from '../errors/jwt-error.class';\nimport {\n\tDEFAULT_HEADER_CONFIG,\n\tHeaderConfiguration,\n\tUrlFilter,\n} from '../model/header-configuration.interface';\nimport { HttpMethodType } from './http-method.enum';\n\nexport const DEFAULT_JWT_HEADER = 'Authorization';\nexport const DEFAULT_JWT_SCHEME = 'Bearer ';\n\nexport const DEFAULT_JWT_CONFIG: Partial<JwtConfiguration> = {\n\t...DEFAULT_HEADER_CONFIG,\n\theader: DEFAULT_JWT_HEADER,\n\tscheme: DEFAULT_JWT_SCHEME,\n\thandleWithCredentials: true,\n};\n\nexport const DEFAULT_JWT_REFRESH_CONFIG_DEFAULT_AUTO_IN_GUARD = true;\n\nexport const DEFAULT_JWT_REFRESH_CONFIG: Partial<JwtRefreshConfiguration<unknown, unknown>> = {\n\tmethod: 'POST',\n\terrorCodeWhitelist: [401],\n\tisAutoRefreshAllowedInLoginGuardByDefault: DEFAULT_JWT_REFRESH_CONFIG_DEFAULT_AUTO_IN_GUARD,\n};\n\nexport interface JwtRefreshResponse {\n\taccessToken: string;\n\trefreshToken?: string;\n}\n\nexport interface HttpRequestInit {\n\theaders?: HttpHeaders;\n\treportProgress?: boolean;\n\tparams?: HttpParams;\n\tresponseType?: 'arraybuffer' | 'blob' | 'json' | 'text';\n\twithCredentials?: boolean;\n}\n\n/**\n * TODO: optional generic matcher function\n */\nexport interface HttpErrorFilter {\n\t/**\n\t * The error codes on which an act is allowed to happen,\n\t * an empty array means it can't act on anything\n\t *\n\t * @default [401]\n\t */\n\terrorCodeWhitelist?: number[];\n\n\t/**\n\t * The error codes on which an act is not allowed to happen,\n\t * an empty array (and if undefined) means it can always try a single\n\t * act in case of an error\n\t *\n\t * @default undefined\n\t */\n\terrorCodeBlacklist?: number[];\n}\n\n/**\n * Enables the RefreshInterceptor which will automatically tries to\n * refresh the accessToken on expiration or failure of the next request.\n *\n * Because handling refreshes is not standardized, instead of asking for the\n * refresh token directly I ask you to provide the request itself, however you\n * like to. In these callbacks you can access your refreshToken wherever you\n * store it.\n *\n * You can still configure a `getRefreshToken` property but it's optional,\n * not used in the interceptor at all, and is only used in the helper service.\n * If you do not with to interact with the parsed refreshToken (Usually you\n * don't need to) you can leave that out. But it's there if you might need it.\n *\n * The reason it's configured through multiple properties instead of a callback\n * where I let you do the refresh request however you see fit is to make sure the\n * refreshUrl is known to avoid potentional infinite requests when hitting the\n * refresh endpoint. This way you don't have to remember setting this into the\n * url filter manually.\n *\n * @example configuration.\n * AuthCoreModule.forRoot<TokenStorageService>({\n *\t\tuseFactory: (service: TokenStorageService) => ({\n *\t\t\tgetToken: service.accessToken$\n *\t\t\tautoRefresher: {\n * \t\t\t\tendpoint: `${environment.api}/auth/refresh`,\n * \t\t\t\tsetToken: (response) => service.accessToken$.next(response.accessToken)\n * \t\t\t}\n *\t\t}),\n *\t\tdeps: [TokenStorageService],\n * })\n *\n * @default undefined\n */\nexport interface JwtRefreshConfiguration<RefreshRequest, RefreshResponse>\n\textends UrlFilter,\n\t\tHttpErrorFilter {\n\t/**\n\t * After a successful refresh, this callback will be called.\n\t * You need to define a function which will save the the token in a way\n\t * that if the interceptor calls `getToken` again, it will get the token\n\t * saved with this method.\n\t *\n\t * On a failed refresh it will set the access token as undefined.\n\t *\n\t * @example using `localStorage`\n\t * \t\tsetToken: (response) => localStorage.setItem('accessToken', response.accessToken)\n\t * @example using a service.\n\t *\n\t * ```typescript\n\t * AuthCoreModule.forRoot<TokenStorageService>({\n\t *\t\tuseFactory: (service: TokenStorageService) => ({\n\t *\t\t\tgetToken: service.accessToken$\n\t *\t\t\tautoRefresher: {\n\t * \t\t\t\tendpoint: `${environment.api}/auth/refresh`,\n\t * \t\t\t\tsetRefreshToken: (response) => service.accessToken$.next(response.accessToken)\n\t * \t\t\t}\n\t *\t\t}),\n\t *\t\tdeps: [TokenStorageService],\n\t * })\n\t * ```\n\t *\n\t */\n\tsetRefreshedTokens: (response: Partial<JwtRefreshResponse>) => void;\n\n\t/**\n\t * The method for the request, usually it's a POST so that's the default\n\t *\n\t * @default 'POST'\n\t */\n\tmethod?: HttpMethodType;\n\n\t/**\n\t * The endpoint that will be requested for a new token\n\t */\n\trefreshUrl: string;\n\n\t/**\n\t * A callback or observable that can be used to retrieve the body of the\n\t * request. If it's null or undefined, the refresh won't be executed. This\n\t * can be utilized to not do a refresh on a logged out state.\n\t *\n\t * @example getValue: () => localstorage.get('foo')\n\t * @example getValue: myTokenService.foo$\n\t */\n\tcreateRefreshRequestBody:\n\t\t| Observable<RefreshRequest | null | undefined>\n\t\t| (() =>\n\t\t\t\t| RefreshRequest\n\t\t\t\t| null\n\t\t\t\t| undefined\n\t\t\t\t| Promise<RefreshRequest | null | undefined>\n\t\t\t\t| Observable<RefreshRequest | null | undefined>);\n\n\t/**\n\t * A callback that should return the defaults on the request\n\t */\n\trefreshRequestInitials?: (() => HttpRequestInit | undefined) | HttpRequestInit;\n\n\t/**\n\t * This function have to transform the result of your refresh endpoint\n\t * into a digestable form. It will be called after successful refreshes.\n\t */\n\ttransformRefreshResponse: (response: RefreshResponse) => JwtRefreshResponse;\n\n\t/**\n\t * This callback is called when a refresh either failed or cannot be done.\n\t * This marks the point where both tokens are invalid and the user needs to\n\t * relog. Because this is usually done through a login page, aside from a\n\t * regular callback, a string can also be supplied which will act as the\n\t * target of navigation. Check `onFailureRedirectParameters` if you wish\n\t * to supply query parameters. For more advanced usage, consider\n\t * implementing it as a custom function, the error object is available\n\t * there too!\n\t */\n\tonFailure?: string | ((error: JwtCouldntRefreshError | JwtCannotRefreshError) => void);\n\n\tonFailureRedirectParameters?:\n\t\t| ((error: JwtCouldntRefreshError | JwtCannotRefreshError) => HttpParams | Params)\n\t\t| HttpParams\n\t\t| Params;\n\n\t/**\n\t * Optional!\n\t *\n\t * The refresh mechanic only uses this to determine if it's expired or not\n\t * and so potentionally saving a request that would fail anyway. It is\n\t * also used in the helper service if you with to interact with the\n\t * parsed refreshToken throught the helper observables. If you do not\n\t * need either of these, you don't have to implement this.\n\t *\n\t * A callback or observable that can be used to retrieve the refresh token\n\t * Not used in the interceptor!\n\t *\n\t * @example getValue: () => localstorage.get('foo')\n\t * @example getValue: myTokenService.foo$\n\t */\n\tgetRefreshToken?:\n\t\t| Observable<string | null | undefined>\n\t\t| (() =>\n\t\t\t\t| string\n\t\t\t\t| null\n\t\t\t\t| undefined\n\t\t\t\t| Promise<string | null | undefined>\n\t\t\t\t| Observable<string | null | undefined>);\n\n\t/**\n\t * When using the LoginGuard this setting will determine the default\n\t * value. So instead of disabling the autoRefresh behavior on every\n\t * route with the data option, or writing your own guard (Which would\n\t * be really simple) just set this to false. You can still override it\n\t * using route data.\n\t *\n\t * See the LoginGuardData helper interface to see what it can utilize.\n\t *\n\t * @default true\n\t */\n\tisAutoRefreshAllowedInLoginGuardByDefault?: boolean;\n}\n\n/**\n * This is a helper interface because they look the same on both\n * `JwtConfiguration` and `JwtRefreshConfiguration`. They are re-defined\n * on them to provide better documentation.\n *\n * In the case where you wish to implement them both in a separate object\n * then spread it back to both to reduce code-duplication, this type can\n * be utilized.\n */\nexport interface JwtErrorHandling {\n\t/**\n\t * If it's a string, instead of calling it, a redirection will happen,\n\t * with `onFailureRedirectParameters` as it's queryParams.\n\t */\n\tonFailure?:\n\t\t| string\n\t\t| ((jwtError: JwtError | JwtCouldntRefreshError | JwtCannotRefreshError) => void);\n\n\t/**\n\t * This option is only used when the `onFailure` option is a string\n\t * so it's handled as a redirect. When this happens, you can define\n\t * the queryparams to be used with this redirect.\n\t *\n\t * When implemented as a function, the JwtError will be forwarded to it.\n\t * All JwtErrors have the `originalRequest` available in them, so it's\n\t * trivial to acquire the failed url.\n\t */\n\tonFailureRedirectParameters?:\n\t\t| ((\n\t\t\t\terror: JwtError | JwtCouldntRefreshError | JwtCannotRefreshError\n\t\t  ) => HttpParams | Params)\n\t\t| HttpParams\n\t\t| Params;\n}\n\n/**\n * Token injection configuration\n *\n * The optional generic defined the refresh endpoints Response type. If you\n * are not using that feature there's no need to define it.\n *\n * Example configuration:\n * ```typescript\n * AuthCoreModule.forRoot<TokenStorageService>({\n *\t\tuseFactory: (service: TokenStorageService) => ({\n *\t\t\tgetToken: service.accessToken$\n *\t\t\tautoRefresher: {\n * \t\t\t\tendpoint: `${environment.api}/auth/refresh`,\n * \t\t\t\tsetToken: (response) => service.accessToken$.next(response.accessToken)\n * \t\t\t}\n *\t\t}),\n *\t\tdeps: [TokenStorageService],\n * })\n * ```\n */\nexport interface JwtConfiguration extends Omit<HeaderConfiguration, 'getValue'>, JwtErrorHandling {\n\t/**\n\t * A callback or observable that will be called or subscribed to\n\t * on every http request and returns a value for the header\n\t *\n\t * @example getValue: () => localstorage.get('foo')\n\t * @example getValue: myTokenService.foo$\n\t */\n\tgetToken:\n\t\t| Observable<string | null | undefined>\n\t\t| (() =>\n\t\t\t\t| string\n\t\t\t\t| null\n\t\t\t\t| undefined\n\t\t\t\t| Promise<string | null | undefined>\n\t\t\t\t| Observable<string | null | undefined>);\n\n\t/**\n\t * The prefix of the token when injecting. Notice thet the trailing\n\t * whitespace has to be set here\n\t *\n\t * @default 'Bearer '\n\t */\n\tscheme?: string;\n\n\t/**\n\t * Header name to be set\n\t *\n\t * @default 'Authorization'\n\t */\n\theader: string;\n\n\t/**\n\t * Sets the 'withCredentials' to true along with the token\n\t *\n\t * @default true\n\t */\n\thandleWithCredentials: boolean;\n\n\t/**\n\t * This callback is called when the request fails and there is no\n\t * RefreshConfiguration, or when the access token is simply missing.\n\t * `getToken` returned a nullish value. If the RefreshConfiguration is\n\t * available, then the error handling continues in the same fashion on\n\t * the other configuration.\n\t *\n\t * Both have the same names and signature for\n\t * both the error handling configuration options `onFailure` and\n\t * `onFailureRedirectParameters`, so if you wish to use the same for both\n\t * implement them outside, and spread them back. You can use the\n\t * `JwtErrorHandling` interface to help you with the typing. Although\n\t * thats a bit wider when it comes to the error types.\n\t *\n\t * If it's a string, instead of calling it, a redirection will happen,\n\t * with `onFailureRedirectParameters` as it's queryParams.\n\t */\n\tonFailure?: string | ((jwtError: JwtError) => void);\n\n\tonFailureRedirectParameters?: ((error: JwtError) => HttpParams | Params) | HttpParams | Params;\n}\n","import { HttpErrorResponse, HttpRequest } from '@angular/common/http';\n\nexport class JwtError extends Error {\n\tstatic type = 'JWT_ERROR';\n\n\tpublic constructor(\n\t\tpublic readonly originalRequest: HttpRequest<unknown> | undefined,\n\t\tpublic readonly originalError: unknown,\n\t\tmessage = JwtError.type\n\t) {\n\t\tsuper(message);\n\t}\n\n\tstatic createErrorResponse(\n\t\trequest: HttpRequest<unknown> | undefined,\n\t\trefreshError: unknown\n\t): HttpErrorResponse {\n\t\treturn new HttpErrorResponse({\n\t\t\terror: JwtError.createErrorEvent(request, refreshError),\n\t\t});\n\t}\n\n\tstatic createErrorEvent(\n\t\trequest: HttpRequest<unknown> | undefined,\n\t\trefreshError: unknown\n\t): ErrorEvent {\n\t\treturn new ErrorEvent(JwtError.type, {\n\t\t\terror: new JwtError(request, refreshError),\n\t\t});\n\t}\n}\n\n/**\n * When both access and refresh tokens are either invalid or expired!\n */\nexport class JwtCannotRefreshError extends JwtError {\n\tstatic type = 'JWT_CANNOT_REFRESH_ERROR';\n\n\tpublic constructor(\n\t\tpublic readonly originalRequest: HttpRequest<unknown> | undefined,\n\t\tpublic readonly originalError: unknown\n\t) {\n\t\tsuper(originalRequest, originalError, JwtCannotRefreshError.type);\n\t}\n\n\tstatic createErrorResponse(\n\t\trequest: HttpRequest<unknown> | undefined,\n\t\trefreshError: unknown\n\t): HttpErrorResponse {\n\t\treturn new HttpErrorResponse({\n\t\t\terror: JwtCannotRefreshError.createErrorEvent(request, refreshError),\n\t\t});\n\t}\n\n\tstatic createErrorEvent(\n\t\trequest: HttpRequest<unknown> | undefined,\n\t\trefreshError: unknown\n\t): ErrorEvent {\n\t\treturn new ErrorEvent(JwtCannotRefreshError.type, {\n\t\t\terror: new JwtCannotRefreshError(request, refreshError),\n\t\t});\n\t}\n}\n\n/**\n * When refresh failed\n */\nexport class JwtCouldntRefreshError extends JwtError {\n\tstatic type = 'JWT_COULDNT_REFRESH_ERROR';\n\n\tpublic constructor(\n\t\tpublic readonly originalRequest: HttpRequest<unknown> | undefined,\n\t\tpublic readonly originalError: unknown\n\t) {\n\t\tsuper(originalRequest, originalError, JwtCouldntRefreshError.type);\n\t}\n\n\tstatic createErrorResponse(\n\t\trequest: HttpRequest<unknown> | undefined,\n\t\trefreshError: unknown\n\t): HttpErrorResponse {\n\t\treturn new HttpErrorResponse({\n\t\t\terror: JwtCouldntRefreshError.createErrorEvent(request, refreshError),\n\t\t});\n\t}\n\n\tstatic createErrorEvent(\n\t\trequest: HttpRequest<unknown> | undefined,\n\t\trefreshError: unknown\n\t): ErrorEvent {\n\t\treturn new ErrorEvent(JwtCouldntRefreshError.type, {\n\t\t\terror: new JwtCouldntRefreshError(request, refreshError),\n\t\t});\n\t}\n}\n","export const isString = (stringLike: unknown): stringLike is string =>\n\ttypeof stringLike === 'string';\n","import { HttpParams } from '@angular/common/http';\nimport { Params, Router } from '@angular/router';\nimport { isString } from '../function/string.predicate';\n\n/**\n * Jwt failures are handled by either calling a callback or if its a string,\n * redirect\n *\n * @internal\n */\nexport const handleJwtFailure = <E>(\n\terrorCallbackOrRedirect: string | ((e: E) => void),\n\terror: E,\n\trouter?: Router,\n\tredirectParameters?: ((e: E) => HttpParams | Params) | HttpParams | Params\n): void => {\n\tif (isString(errorCallbackOrRedirect)) {\n\t\tif (router) {\n\t\t\tlet queryParams = redirectParameters;\n\t\t\tif (typeof redirectParameters === 'function') {\n\t\t\t\tqueryParams = redirectParameters(error);\n\t\t\t}\n\n\t\t\trouter.navigate([errorCallbackOrRedirect], {\n\t\t\t\tqueryParams,\n\t\t\t});\n\t\t} else {\n\t\t\t// This error is intended to surface as it's a configuration problem\n\t\t\tthrow new Error(\n\t\t\t\t'JWT Refresh configuration error! ' +\n\t\t\t\t\t'`onFailure` is defined as a string, but the ' +\n\t\t\t\t\t'Router is not available! Is @angular/router ' +\n\t\t\t\t\t'installed and the RouterModule imported?'\n\t\t\t);\n\t\t}\n\t} else {\n\t\terrorCallbackOrRedirect(error);\n\t}\n};\n","export const isNotNullish = <T>(t: T | undefined | null): t is T => t !== undefined && t !== null;\n","import { HttpErrorResponse } from '@angular/common/http';\nimport { Router } from '@angular/router';\nimport { Observable, throwError } from 'rxjs';\nimport { JwtCannotRefreshError, JwtCouldntRefreshError, JwtError } from '../errors/jwt-error.class';\nimport {\n\tJwtConfiguration,\n\tJwtRefreshConfiguration,\n} from '../model/auth-core-configuration.interface';\nimport { handleJwtFailure } from './handle-jwt-failure.function';\nimport { isNotNullish } from './is-not-nullish.predicate';\n\nexport const handleJwtError = <RefreshRequest = unknown, RefreshResponse = unknown>(\n\twrappedError:\n\t\t| (Omit<HttpErrorResponse, 'error'> & {\n\t\t\t\terror?: Omit<ErrorEvent, 'error'> & {\n\t\t\t\t\terror: JwtError | JwtCannotRefreshError | JwtCouldntRefreshError;\n\t\t\t\t};\n\t\t  })\n\t\t| { error?: { error: JwtError | JwtCannotRefreshError | JwtCouldntRefreshError } },\n\tjwtConfiguration: JwtConfiguration,\n\tjwtRefreshConfiguration?: JwtRefreshConfiguration<RefreshRequest, RefreshResponse>,\n\trouter?: Router\n): Observable<never> => {\n\tconst error: undefined | JwtError | JwtCannotRefreshError | JwtCouldntRefreshError =\n\t\twrappedError.error?.error;\n\n\tif (error instanceof JwtCannotRefreshError || error instanceof JwtCouldntRefreshError) {\n\t\tif (jwtRefreshConfiguration && isNotNullish(jwtRefreshConfiguration.onFailure)) {\n\t\t\t// Unset accesstoken\n\t\t\t// jwtRefreshConfiguration.setRefreshedTokens({ accessToken: undefined });\n\n\t\t\thandleJwtFailure(\n\t\t\t\tjwtRefreshConfiguration.onFailure,\n\t\t\t\terror,\n\t\t\t\trouter,\n\t\t\t\tjwtRefreshConfiguration.onFailureRedirectParameters\n\t\t\t);\n\t\t}\n\t\t// Rethrow the inner error, so observers of the user can see it\n\t\treturn throwError(error);\n\t} else if (error instanceof JwtError) {\n\t\tif (isNotNullish(jwtConfiguration.onFailure)) {\n\t\t\thandleJwtFailure(\n\t\t\t\tjwtConfiguration.onFailure,\n\t\t\t\terror,\n\t\t\t\trouter,\n\t\t\t\tjwtConfiguration.onFailureRedirectParameters\n\t\t\t);\n\t\t}\n\t\treturn throwError(error);\n\t} else {\n\t\t// Other errors are left untreated\n\t\treturn throwError(wrappedError);\n\t}\n};\n","export const isFunction = <Return>(funlike: unknown): funlike is () => Return =>\n\ttypeof funlike === 'function';\n","/**\n * Returns true if the object is truthy and has a `then` and a `catch` function.\n * Using `instanceof` would not be sufficient as Promises can be contructed\n * in many ways, and it's just a specification.\n */\nexport const isPromise = <T>(promiseLike: unknown): promiseLike is Promise<T> =>\n\t!!promiseLike &&\n\ttypeof (promiseLike as Promise<T>).then === 'function' &&\n\ttypeof (promiseLike as Promise<T>).catch === 'function';\n","import { from, isObservable, Observable, of } from 'rxjs';\nimport { switchMap } from 'rxjs/operators';\nimport { isFunction } from './function.predicate';\nimport { isPromise } from './promise.predicate';\n\n/**\n * Returns a cold observable from a function, or returns an observable if\n * one is directly passed to it\n */\nexport const intoObservable = <T>(\n\tgetValue: T | Observable<T> | Promise<T> | (() => T | Promise<T> | Observable<T>)\n): Observable<T> => {\n\tif (isObservable(getValue)) {\n\t\treturn getValue;\n\t} else if (isFunction(getValue)) {\n\t\treturn of(null).pipe(\n\t\t\tswitchMap(() => {\n\t\t\t\tconst result = getValue();\n\t\t\t\tif (isObservable(result)) {\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t\tif (isPromise(result)) {\n\t\t\t\t\treturn from(result);\n\t\t\t\t} else {\n\t\t\t\t\treturn of(result);\n\t\t\t\t}\n\t\t\t})\n\t\t);\n\t} else if (isPromise(getValue)) {\n\t\treturn from(getValue);\n\t} else {\n\t\treturn of(getValue);\n\t}\n};\n","import { merge, Observable, of, timer } from 'rxjs';\nimport { mapTo } from 'rxjs/operators';\n\n/**\n * It returns an observable which emits instantly a boolean describing if the\n * timestamp is expired or not. If not, it will emit a second time when it\n * will expire.\n *\n * @param timestamp milliseconds\n */\nexport const isTimestampExpiredNowAndWhenItIs = (timestamp: number): Observable<boolean> => {\n\t// If already expired, just return that\n\tif (timestamp - new Date().getTime() < 0) {\n\t\treturn of(true);\n\t} else {\n\t\t// If not, return that is not and a timer that will emit when it does\n\t\treturn merge(of(false), timer(new Date(timestamp)).pipe(mapTo(true)));\n\t}\n};\n","import { Observable } from 'rxjs';\nimport { isTimestampExpiredNowAndWhenItIs } from './is-timestamp-expired-now-and-when-it-is.function';\n\n/**\n * It returns an observable which emits instantly a boolean describing if the\n * timestamp is expired or not. If not, it will emit a second time when it\n * will expire.\n *\n * @param unixTimestamp seconds from the unix epoch 1970-01-01T00:00:00Z\n * if not supplied it will always be expired\n */\nexport const isUnixTimestampExpiredNowAndWhenItIs = (unixTimestamp: number): Observable<boolean> =>\n\tisTimestampExpiredNowAndWhenItIs(Math.floor(unixTimestamp * 1000));\n","import { HttpErrorResponse } from '@angular/common/http';\nimport { HttpErrorFilter } from '../model/auth-core-configuration.interface';\n\n/**\n * Matches the filter against an error response. Non-existend rulesets\n * automatically pass. **Empty whitelist rulesets never pass.** Empty blacklist\n * rulesets always pass.\n */\nexport const checkAgainstHttpErrorFilter = (\n\thttpErrorFilter: HttpErrorFilter,\n\terror: HttpErrorResponse\n): boolean => {\n\tconst statusMatcher = (code: number) => code === error.status;\n\tconst errorCodeWhitelistRulesPass =\n\t\thttpErrorFilter.errorCodeWhitelist?.some(statusMatcher) ?? true;\n\n\tconst errorCodeBlacklistRulesPass = !httpErrorFilter.errorCodeBlacklist?.some(statusMatcher);\n\n\treturn errorCodeWhitelistRulesPass && errorCodeBlacklistRulesPass;\n};\n","import { isFunction } from './function.predicate';\n\nexport const callWhenFunction = <T = unknown>(functionLike: (() => T) | T): T => {\n\tlet result;\n\tif (isFunction<T>(functionLike)) {\n\t\tresult = functionLike();\n\t} else {\n\t\tresult = functionLike;\n\t}\n\treturn result;\n};\n","import { HttpEvent, HttpEventType, HttpResponse } from '@angular/common/http';\n\nexport const isHttpResponse = <T>(httpEvent: HttpEvent<T>): httpEvent is HttpResponse<T> =>\n\thttpEvent.type === HttpEventType.Response;\n","import { HttpHandler, HttpRequest } from '@angular/common/http';\nimport { BehaviorSubject, Observable } from 'rxjs';\nimport { catchError, filter, finalize, map, mergeMap, tap } from 'rxjs/operators';\nimport {\n\tJwtRefreshConfiguration,\n\tJwtRefreshResponse,\n} from '../model/auth-core-configuration.interface';\nimport { callWhenFunction } from './call-when-function.function';\nimport { isHttpResponse } from './http-response.predicate';\n\nexport const doJwtRefresh = <Req, Res, Ret>(\n\tnext: HttpHandler,\n\trequestBody: Req,\n\tjwtRefreshConfiguration: JwtRefreshConfiguration<Req, Res>,\n\trefreshLock: BehaviorSubject<boolean>,\n\tonError: (refreshError: unknown) => Observable<Ret>,\n\toriginalAction: (refreshResponse: JwtRefreshResponse) => Observable<Ret>\n): Observable<Ret> => {\n\tconst refreshRequest = new HttpRequest<Req>(\n\t\tjwtRefreshConfiguration.method ?? 'POST',\n\t\tjwtRefreshConfiguration.refreshUrl,\n\t\trequestBody,\n\t\tcallWhenFunction(jwtRefreshConfiguration.refreshRequestInitials)\n\t);\n\trefreshLock.next(true); // Lock on refresh\n\treturn next.handle(refreshRequest).pipe(\n\t\tfilter(isHttpResponse),\n\t\tmap((response) => jwtRefreshConfiguration.transformRefreshResponse(response.body)),\n\t\ttap((refreshResponse) => jwtRefreshConfiguration.setRefreshedTokens(refreshResponse)),\n\t\tmergeMap((refreshResponse) => originalAction(refreshResponse)),\n\t\tfinalize(() => refreshLock.next(false)), // Unlock on finish\n\t\tcatchError(onError)\n\t);\n};\n","import { HttpErrorResponse, HttpHandler } from '@angular/common/http';\nimport { BehaviorSubject, Observable, throwError } from 'rxjs';\nimport { switchMap, take } from 'rxjs/operators';\nimport {\n\tJwtRefreshConfiguration,\n\tJwtRefreshResponse,\n} from '../model/auth-core-configuration.interface';\nimport { checkAgainstHttpErrorFilter } from './check-against-http-error-filter.function';\nimport { doJwtRefresh } from './do-jwt-refresh.function';\nimport { intoObservable } from './into-observable.function';\n\nexport const tryJwtRefresh = <Req, Res, Ret>(\n\tnext: HttpHandler,\n\toriginalError: string | HttpErrorResponse,\n\tjwtRefreshConfiguration: JwtRefreshConfiguration<Req, Res>,\n\trefreshLock: BehaviorSubject<boolean>,\n\tonError: (refreshError: unknown) => Observable<Ret>,\n\toriginalAction: (refreshResponse: JwtRefreshResponse) => Observable<Ret>\n): Observable<Ret> => {\n\tconst isRefreshAllowed =\n\t\ttypeof originalError === 'string' ||\n\t\tcheckAgainstHttpErrorFilter(jwtRefreshConfiguration, originalError);\n\n\tif (isRefreshAllowed) {\n\t\treturn intoObservable(jwtRefreshConfiguration.createRefreshRequestBody).pipe(\n\t\t\ttake(1),\n\t\t\tswitchMap((requestBody) => {\n\t\t\t\tif (requestBody) {\n\t\t\t\t\treturn doJwtRefresh(\n\t\t\t\t\t\tnext,\n\t\t\t\t\t\trequestBody,\n\t\t\t\t\t\tjwtRefreshConfiguration,\n\t\t\t\t\t\trefreshLock,\n\t\t\t\t\t\tonError,\n\t\t\t\t\t\toriginalAction\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\treturn onError(originalError);\n\t\t\t\t}\n\t\t\t})\n\t\t);\n\t} else {\n\t\treturn throwError(originalError);\n\t}\n};\n","import { Base64 } from 'js-base64';\n\nexport type Base64String = string;\nexport type JsonString = string;\n\n/**\n *\n * @param str json encoded in Base64\n */\nexport const decodeJsonLikeBase64 = <T = Record<string, unknown>>(str: Base64String): T | null => {\n\ttry {\n\t\treturn JSON.parse(Base64.decode(str));\n\t} catch (error) {\n\t\tconsole.error('Invalid Jsonlike Base64 string', error);\n\t\treturn null;\n\t}\n};\n","import { Base64 } from 'js-base64';\nimport { Base64String, decodeJsonLikeBase64 } from '../function/base64-decoder.function';\nimport { isUnixTimestampExpired } from '../function/is-unix-timestamp-expired.function';\n\nexport type JwtTokenString = string;\nexport type UnixTime = number;\n\nexport interface JwtTokenHeader {\n\t/**\n\t * Media type\n\t */\n\ttyp?: string;\n\t/**\n\t * Content Type\n\t */\n\tcty?: 'JWT' | string;\n\t/**\n\t * Algorithm\n\t */\n\talg: string;\n\t/**\n\t * Encryption\n\t */\n\tenc?: string;\n}\n\n/**\n * Registered claim names defined in RFC 7519 are predefined here.\n */\nexport interface JwtTokenPayload {\n\t/**\n\t * Issuer\n\t */\n\tiss?: string;\n\t/**\n\t * Subject\n\t */\n\tsub?: string;\n\t/**\n\t * Audience\n\t */\n\taud?: string;\n\t/**\n\t * Expiration Time\n\t */\n\texp: UnixTime;\n\t/**\n\t * Not Before\n\t */\n\tnbf?: UnixTime;\n\t/**\n\t * Issued at\n\t */\n\tiat?: UnixTime;\n\t/**\n\t * JWT ID\n\t */\n\tjti?: string;\n}\n\n/**\n * Common token pair\n */\nexport interface JwtTokenPair {\n\taccessToken: JwtTokenString;\n\trefreshToken: JwtTokenString;\n}\n\nexport class JwtToken<Claims = Record<string | number, unknown>> {\n\tpublic static readonly JWT_TOKEN_SEPARATOR = '.';\n\n\tpublic constructor(\n\t\tpublic header: JwtTokenHeader,\n\t\tpublic payload: JwtTokenPayload & Claims,\n\t\tpublic signature: string\n\t) {}\n\n\tpublic static from<FromClaims = Record<string | number, unknown>>(\n\t\ttoken: JwtTokenString\n\t): JwtToken<FromClaims> | null {\n\t\tconst convertedSegments = JwtToken.splitTokenString(token);\n\t\tif (!convertedSegments) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst header = decodeJsonLikeBase64<JwtTokenHeader>(convertedSegments[0]);\n\t\tconst payload = decodeJsonLikeBase64<JwtTokenPayload & FromClaims>(convertedSegments[1]);\n\t\tconst signature = Base64.decode(convertedSegments[2]); // Not used, only for validation\n\t\tif (!header || !payload || !signature) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn new JwtToken<FromClaims>(header, payload, signature);\n\t}\n\n\tpublic static stripScheme(jwtHeaderValue: string, scheme?: string): JwtTokenString {\n\t\treturn jwtHeaderValue.substring((scheme ?? '').length);\n\t}\n\n\tpublic static splitTokenString(\n\t\ttoken: JwtTokenString,\n\t\tseparator: string = JwtToken.JWT_TOKEN_SEPARATOR\n\t): [Base64String, Base64String, Base64String] | null {\n\t\tconst spl = token.split(separator);\n\t\tif (spl.length !== 3) {\n\t\t\treturn null;\n\t\t}\n\t\treturn spl as [Base64String, Base64String, Base64String];\n\t}\n\n\tpublic isExpired(): boolean {\n\t\treturn isUnixTimestampExpired(this.payload.exp);\n\t}\n}\n","import { InjectionToken } from '@angular/core';\nimport {\n\tJwtConfiguration,\n\tJwtRefreshConfiguration,\n} from '../model/auth-core-configuration.interface';\nimport { TypedProvider } from '../model/typed-providers.interface';\n\nexport const JWT_CONFIGURATION_TOKEN = new InjectionToken<JwtConfiguration>(\n\t'AegisJwtConfiguration'\n);\n\nexport const DEFAULT_JWT_CONFIGURATION_TOKEN = new InjectionToken<Partial<JwtConfiguration>>(\n\t'DefaultAegisJwtConfiguration'\n);\n\nexport const JWT_REFRESH_CONFIGURATION_TOKEN = new InjectionToken<\n\tJwtRefreshConfiguration<unknown, unknown>\n>('AegisJwtRefreshConfiguration');\n\nexport const DEFAULT_JWT_REFRESH_CONFIGURATION_TOKEN = new InjectionToken<\n\tPartial<JwtRefreshConfiguration<unknown, unknown>>\n>('DefaultAegisJwtRefreshConfiguration');\n\n/**\n * To provide an {@link AuthTokenConfiguration |  AuthTokenConfiguration}\n */\nexport type JwtConfigurationProvider<> = TypedProvider<JwtConfiguration>;\n\n/**\n * To provide an {@link AuthTokenConfiguration |  AuthTokenConfiguration}\n */\nexport type JwtRefreshConfigurationProvider<RefreshRequest, RefreshResponse> = TypedProvider<\n\tJwtRefreshConfiguration<RefreshRequest, RefreshResponse>\n>;\n\n/**\n * This type describes a providerlike object that doesn't have a provide field\n * because that will be defaulted by the\n * {@link createRefreshableAuthTokenProvider | createRefreshableAuthTokenProvider }\n * function\n */\nexport type JwtModuleConfigurationProvider = Partial<\n\tOmit<TypedProvider<Partial<JwtConfiguration>>, 'provide' | 'multi'>\n>;\n\nexport type JwtModuleRefreshConfigurationProvider<RefreshRequest, RefreshResponse> = Partial<\n\tOmit<\n\t\tTypedProvider<Partial<JwtRefreshConfiguration<RefreshRequest, RefreshResponse>>>,\n\t\t'provide' | 'multi'\n\t>\n>;\n","import { Injectable } from '@angular/core';\nimport { BehaviorSubject } from 'rxjs';\n\n@Injectable({\n\tprovidedIn: 'root',\n})\nexport class JwtRefreshStateService {\n\tpublic readonly refreshLock$ = new BehaviorSubject(false);\n}\n","import { HttpHandler } from '@angular/common/http';\nimport { Inject, Injectable, Optional } from '@angular/core';\nimport { Router } from '@angular/router';\nimport { Observable, of } from 'rxjs';\nimport { catchError, map, switchMap } from 'rxjs/operators';\nimport { JwtCouldntRefreshError } from '../errors/jwt-error.class';\nimport { handleJwtError } from '../function/handle-jwt-error.function';\nimport { intoObservable } from '../function/into-observable.function';\nimport { isNotNullish } from '../function/is-not-nullish.predicate';\nimport { isUnixTimestampExpiredNowAndWhenItIs } from '../function/is-unix-timestamp-expired-now-and-when-it-is.function';\nimport { isString } from '../function/string.predicate';\nimport { tryJwtRefresh } from '../function/try-jwt-refresh.function';\nimport {\n\tJwtConfiguration,\n\tJwtRefreshConfiguration,\n} from '../model/auth-core-configuration.interface';\nimport { JwtToken } from '../model/jwt-token.class';\nimport {\n\tDEFAULT_JWT_CONFIGURATION_TOKEN,\n\tDEFAULT_JWT_REFRESH_CONFIGURATION_TOKEN,\n\tJWT_CONFIGURATION_TOKEN,\n\tJWT_REFRESH_CONFIGURATION_TOKEN,\n} from '../token/jwt-configuration.token';\nimport { JwtRefreshStateService } from './jwt-refresh-state.service';\n\n@Injectable({\n\tprovidedIn: 'root',\n})\nexport class JwtTokenService<\n\tClaims = Record<string | number, unknown>,\n\tRefreshClaims = Record<string | number, unknown>,\n\tRefreshRequest = Record<string | number, unknown>,\n\tRefreshResponse = Record<string | number, unknown>\n> {\n\tpublic readonly config: JwtConfiguration = {\n\t\t...this.rawDefaultConfig,\n\t\t...this.rawConfig,\n\t};\n\n\tpublic readonly refreshConfig?: JwtRefreshConfiguration<RefreshRequest, RefreshResponse> =\n\t\tthis.rawDefaultRefreshConfig && this.rawRefreshConfig\n\t\t\t? {\n\t\t\t\t\t...this.rawDefaultRefreshConfig,\n\t\t\t\t\t...this.rawRefreshConfig,\n\t\t\t  }\n\t\t\t: undefined;\n\n\t/**\n\t * Consider restricting getToken to observables only so things can be cached\n\t */\n\tpublic readonly rawAccessToken$ = intoObservable(this.config.getToken);\n\n\tpublic readonly rawRefreshToken$ = this.refreshConfig?.getRefreshToken\n\t\t? intoObservable(this.refreshConfig.getRefreshToken)\n\t\t: of(null);\n\n\tpublic readonly accessToken$ = this.rawAccessToken$.pipe(\n\t\tmap((token) => {\n\t\t\tif (isString(token)) {\n\t\t\t\tconst jwtToken = JwtToken.from<Claims>(token);\n\t\t\t\tif (!jwtToken) {\n\t\t\t\t\tthrow new Error('Non-valid token observed');\n\t\t\t\t} else {\n\t\t\t\t\treturn jwtToken;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t})\n\t);\n\n\tpublic readonly refreshToken$ = this.rawRefreshToken$.pipe(\n\t\tmap((refreshToken) => {\n\t\t\tif (isString(refreshToken)) {\n\t\t\t\tconst jwtToken = JwtToken.from<RefreshClaims>(refreshToken);\n\t\t\t\tif (!jwtToken) {\n\t\t\t\t\tthrow new Error('Non-valid token observed');\n\t\t\t\t} else {\n\t\t\t\t\treturn jwtToken;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t})\n\t);\n\n\tpublic readonly accessTokenHeader$ = this.accessToken$.pipe(\n\t\tmap((token) => token?.header ?? null)\n\t);\n\n\tpublic readonly accessTokenPayload$ = this.accessToken$.pipe(\n\t\tmap((token) => token?.payload ?? null)\n\t);\n\n\tpublic readonly refreshTokenHeader$ = this.refreshToken$.pipe(\n\t\tmap((token) => token?.header ?? null)\n\t);\n\n\tpublic readonly refreshTokenPayload$ = this.refreshToken$.pipe(\n\t\tmap((token) => token?.payload ?? null)\n\t);\n\n\tpublic readonly isAccessTokenExpired$ = this.accessToken$.pipe(\n\t\tswitchMap((token) =>\n\t\t\ttoken ? isUnixTimestampExpiredNowAndWhenItIs(token.payload.exp) : of(null)\n\t\t)\n\t);\n\n\tpublic readonly isRefreshTokenExpired$ = this.refreshToken$.pipe(\n\t\tswitchMap((token) =>\n\t\t\ttoken ? isUnixTimestampExpiredNowAndWhenItIs(token.payload.exp) : of(null)\n\t\t)\n\t);\n\n\tpublic readonly isAccessTokenValid$ = this.isAccessTokenExpired$.pipe(\n\t\tmap((isExpired) => isNotNullish(isExpired) && !isExpired)\n\t);\n\n\tpublic readonly isRefreshTokenValid$ = this.isRefreshTokenExpired$.pipe(\n\t\tmap((isExpired) => isNotNullish(isExpired) && !isExpired)\n\t);\n\n\tpublic constructor(\n\t\tprivate readonly httpHandler: HttpHandler,\n\t\tprivate readonly jwtRefreshStateService: JwtRefreshStateService,\n\t\t@Inject(JWT_CONFIGURATION_TOKEN)\n\t\tprivate readonly rawConfig: JwtConfiguration,\n\t\t@Inject(DEFAULT_JWT_CONFIGURATION_TOKEN)\n\t\tprivate readonly rawDefaultConfig: JwtConfiguration,\n\t\t@Inject(DEFAULT_JWT_REFRESH_CONFIGURATION_TOKEN)\n\t\t@Optional()\n\t\tprivate readonly rawDefaultRefreshConfig?: JwtRefreshConfiguration<\n\t\t\tRefreshRequest,\n\t\t\tRefreshResponse\n\t\t>,\n\t\t@Inject(JWT_REFRESH_CONFIGURATION_TOKEN)\n\t\t@Optional()\n\t\tprivate readonly rawRefreshConfig?: JwtRefreshConfiguration<\n\t\t\tRefreshRequest,\n\t\t\tRefreshResponse\n\t\t>,\n\t\t@Optional() private readonly router?: Router\n\t) {}\n\n\t/**\n\t * Does a token refresh. Emits false if it failed, or true if succeeded.\n\t */\n\tpublic manualRefresh(): Observable<boolean> {\n\t\tif (this.refreshConfig) {\n\t\t\treturn tryJwtRefresh(\n\t\t\t\tthis.httpHandler,\n\t\t\t\t'Access token not valid on guard activation',\n\t\t\t\tthis.refreshConfig,\n\t\t\t\tthis.jwtRefreshStateService.refreshLock$,\n\t\t\t\t(refreshError) =>\n\t\t\t\t\thandleJwtError<RefreshRequest, RefreshResponse>(\n\t\t\t\t\t\tJwtCouldntRefreshError.createErrorResponse(undefined, refreshError),\n\t\t\t\t\t\tthis.config,\n\t\t\t\t\t\tthis.refreshConfig,\n\t\t\t\t\t\tthis.router\n\t\t\t\t\t).pipe(catchError(() => of(false))),\n\t\t\t\t() => of(true)\n\t\t\t);\n\t\t} else {\n\t\t\treturn of(false);\n\t\t}\n\t}\n}\n","import { Injectable } from '@angular/core';\nimport {\n\tActivatedRouteSnapshot,\n\tCanActivate,\n\tCanActivateChild,\n\tCanLoad,\n\tRoute,\n\tRouterStateSnapshot,\n\tUrlSegment,\n\tUrlTree,\n} from '@angular/router';\nimport { Observable, of } from 'rxjs';\nimport { switchMap, take } from 'rxjs/operators';\nimport { DEFAULT_JWT_REFRESH_CONFIG_DEFAULT_AUTO_IN_GUARD } from '../model/auth-core-configuration.interface';\nimport { JwtTokenService } from '../service/jwt-token.service';\n\n/**\n * This interface is for your convinience to use with Route data to see what\n * you can configure on the LoginGuard\n */\nexport interface LoginGuardData {\n\t/**\n\t * Explicitly enable or disable auto refreshing on the route.\n\t */\n\tisRefreshAllowed: boolean;\n}\n\n@Injectable({\n\tprovidedIn: 'root',\n})\nexport class LoginGuard implements CanActivate, CanActivateChild, CanLoad {\n\tprivate isAccessTokenValidOnce$ = this.jwtTokenService.isAccessTokenValid$.pipe(take(1));\n\n\tpublic constructor(private readonly jwtTokenService: JwtTokenService) {}\n\n\tpublic canActivate(\n\t\troute: ActivatedRouteSnapshot,\n\t\t_state: RouterStateSnapshot\n\t): Observable<boolean | UrlTree> | Promise<boolean | UrlTree> | boolean | UrlTree {\n\t\tconst data = route.data as LoginGuardData | undefined;\n\t\treturn this.isValid(data?.isRefreshAllowed);\n\t}\n\n\tpublic canActivateChild(\n\t\tchildRoute: ActivatedRouteSnapshot,\n\t\t_state: RouterStateSnapshot\n\t): Observable<boolean | UrlTree> | Promise<boolean | UrlTree> | boolean | UrlTree {\n\t\tconst data = childRoute.data as LoginGuardData | undefined;\n\t\treturn this.isValid(data?.isRefreshAllowed);\n\t}\n\n\tpublic canLoad(\n\t\troute: Route,\n\t\t_segments: UrlSegment[]\n\t): Observable<boolean> | Promise<boolean> | boolean {\n\t\tconst data = route.data as LoginGuardData | undefined;\n\t\treturn this.isValid(data?.isRefreshAllowed);\n\t}\n\n\tprivate isValid(isRefreshAllowed: boolean | undefined): Observable<boolean> {\n\t\tconst allowed =\n\t\t\tisRefreshAllowed ??\n\t\t\tthis.jwtTokenService.refreshConfig?.isAutoRefreshAllowedInLoginGuardByDefault ??\n\t\t\tDEFAULT_JWT_REFRESH_CONFIG_DEFAULT_AUTO_IN_GUARD;\n\t\treturn this.isAccessTokenValidOnce$.pipe(\n\t\t\tswitchMap((isValid) => {\n\t\t\t\tif (!isValid && allowed) {\n\t\t\t\t\treturn this.jwtTokenService.manualRefresh();\n\t\t\t\t} else {\n\t\t\t\t\treturn of(isValid);\n\t\t\t\t}\n\t\t\t})\n\t\t);\n\t}\n}\n","import {\n\tHttpErrorResponse,\n\tHttpEvent,\n\tHttpHandler,\n\tHttpInterceptor,\n\tHttpRequest,\n} from '@angular/common/http';\nimport { Inject, Injectable, Optional } from '@angular/core';\nimport { Router } from '@angular/router';\nimport { Observable } from 'rxjs';\nimport { catchError } from 'rxjs/operators';\nimport { handleJwtError } from '../function/handle-jwt-error.function';\nimport {\n\tJwtConfiguration,\n\tJwtRefreshConfiguration,\n} from '../model/auth-core-configuration.interface';\nimport {\n\tDEFAULT_JWT_CONFIGURATION_TOKEN,\n\tDEFAULT_JWT_REFRESH_CONFIGURATION_TOKEN,\n\tJWT_CONFIGURATION_TOKEN,\n\tJWT_REFRESH_CONFIGURATION_TOKEN,\n} from '../token/jwt-configuration.token';\n\n/**\n * If configured, handles authentication errors with custom callbacks\n * or redirects\n */\n@Injectable()\nexport class JwtErrorHandlingInterceptor implements HttpInterceptor {\n\tprivate readonly jwtConfiguration: JwtConfiguration;\n\tprivate readonly jwtRefreshConfiguration?: JwtRefreshConfiguration<unknown, unknown>;\n\tpublic constructor(\n\t\t@Inject(JWT_CONFIGURATION_TOKEN)\n\t\tjwtConfig: JwtConfiguration,\n\t\t@Inject(DEFAULT_JWT_CONFIGURATION_TOKEN)\n\t\tdefaultJwtConfig: JwtConfiguration,\n\t\t@Optional()\n\t\t@Inject(JWT_REFRESH_CONFIGURATION_TOKEN)\n\t\trefreshConfig?: JwtRefreshConfiguration<unknown, unknown>,\n\t\t@Optional()\n\t\t@Inject(DEFAULT_JWT_REFRESH_CONFIGURATION_TOKEN)\n\t\tdefaultJwtRefreshConfig?: JwtRefreshConfiguration<unknown, unknown>,\n\t\t@Optional() private readonly router?: Router\n\t) {\n\t\tthis.jwtConfiguration = {\n\t\t\t...defaultJwtConfig,\n\t\t\t...jwtConfig,\n\t\t};\n\n\t\tthis.jwtRefreshConfiguration =\n\t\t\tdefaultJwtRefreshConfig && refreshConfig\n\t\t\t\t? {\n\t\t\t\t\t\t...defaultJwtRefreshConfig,\n\t\t\t\t\t\t...refreshConfig,\n\t\t\t\t  }\n\t\t\t\t: undefined;\n\t}\n\tpublic intercept(\n\t\trequest: HttpRequest<unknown>,\n\t\tnext: HttpHandler\n\t): Observable<HttpEvent<unknown>> {\n\t\treturn next\n\t\t\t.handle(request)\n\t\t\t.pipe(\n\t\t\t\tcatchError((errorResponse: HttpErrorResponse) =>\n\t\t\t\t\thandleJwtError(\n\t\t\t\t\t\terrorResponse,\n\t\t\t\t\t\tthis.jwtConfiguration,\n\t\t\t\t\t\tthis.jwtRefreshConfiguration,\n\t\t\t\t\t\tthis.router\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t);\n\t}\n}\n","import { isString } from './string.predicate';\n\nexport const matchRule = (rule: string | RegExp, against?: string | null): boolean => {\n\tif (isString(rule)) {\n\t\treturn rule === against;\n\t} else if (against) {\n\t\treturn rule.test(against);\n\t} else {\n\t\treturn false;\n\t}\n};\n\n/**\n *\n * @param inverse easy negating when composing\n */\nexport const matchAgainst =\n\t(against?: string | null, inverse = false) =>\n\t(rule: string | RegExp): boolean =>\n\t\tinverse ? !matchRule(rule, against) : matchRule(rule, against);\n","import { UrlFilter } from '../model/header-configuration.interface';\nimport { matchAgainst } from './match-against.function';\nimport { SeparatedUrl } from './separate-url.function';\n\n/**\n * Matches the filter against a separated url. Non-existend rulesets\n * automatically pass. **Empty whitelist rulesets never pass.** Empty blacklist\n * rulesets always pass.\n */\nexport const checkAgainstUrlFilter = (\n\turlFilter: UrlFilter,\n\t{ domain, path, protocol }: SeparatedUrl\n): boolean => {\n\tconst protocolMatcher = matchAgainst(protocol);\n\tconst domainMatcher = matchAgainst(domain);\n\tconst pathMatcher = matchAgainst(path);\n\n\tconst protocolWhitelistRulesPass = urlFilter.protocolWhitelist?.some(protocolMatcher) ?? true;\n\n\tconst protocolBlacklistRulesPass = !urlFilter.protocolBlacklist?.some(protocolMatcher);\n\n\tconst domainWhitelistRulesPass = urlFilter.domainWhitelist?.some(domainMatcher) ?? true;\n\n\tconst domainBlacklistRulesPass = !urlFilter.domainBlacklist?.some(domainMatcher);\n\n\tconst pathWhitelistRulesPass = urlFilter.pathWhitelist?.some(pathMatcher) ?? true;\n\n\tconst pathBlacklistRulesPass = !urlFilter.pathBlacklist?.some(pathMatcher);\n\n\treturn (\n\t\tprotocolWhitelistRulesPass &&\n\t\tprotocolBlacklistRulesPass &&\n\t\tdomainWhitelistRulesPass &&\n\t\tdomainBlacklistRulesPass &&\n\t\tpathWhitelistRulesPass &&\n\t\tpathBlacklistRulesPass\n\t);\n};\n","export type UrlProtocol = string;\nexport type UrlDomain = string;\nexport type UrlPath = string;\n\n/**\n * An url separated into optional parts, the separators are not included.\n * Separator between protocol and domain is `://`, and between domain\n * and path is `/`.\n */\nexport interface SeparatedUrl {\n\t/**\n\t * @example `http`\n\t */\n\tprotocol?: UrlProtocol;\n\n\t/**\n\t * @example `localhost`\n\t */\n\tdomain?: UrlDomain;\n\n\t/**\n\t * @example `foo/bar`\n\t */\n\tpath?: UrlPath;\n}\n\n/**\n * Returns the url split into parts, without the separators.\n * Separator between protocol and domain is `://`, and between domain\n * and path is `/`.\n */\nexport const separateUrl = (url?: string): SeparatedUrl => {\n\tconst urlMatch = url?.match(/^((.*):\\/\\/)?([^/].*?)?(\\/(.*))?$/);\n\treturn {\n\t\tprotocol: urlMatch?.[2] as UrlProtocol,\n\t\tdomain: urlMatch?.[3] as UrlDomain,\n\t\tpath: urlMatch?.[5] as UrlPath,\n\t};\n};\n","import { HttpEvent, HttpHandler, HttpInterceptor, HttpRequest } from '@angular/common/http';\nimport { Inject, Injectable, Optional } from '@angular/core';\nimport { Observable, throwError } from 'rxjs';\nimport { switchMap, take } from 'rxjs/operators';\nimport { JwtError } from '../errors/jwt-error.class';\nimport { checkAgainstUrlFilter } from '../function/check-against-url-filter.function';\nimport { intoObservable } from '../function/into-observable.function';\nimport { separateUrl } from '../function/separate-url.function';\nimport {\n\tJwtConfiguration,\n\tJwtRefreshConfiguration,\n} from '../model/auth-core-configuration.interface';\nimport { JwtToken } from '../model/jwt-token.class';\nimport {\n\tDEFAULT_JWT_CONFIGURATION_TOKEN,\n\tDEFAULT_JWT_REFRESH_CONFIGURATION_TOKEN,\n\tJWT_CONFIGURATION_TOKEN,\n\tJWT_REFRESH_CONFIGURATION_TOKEN,\n} from '../token/jwt-configuration.token';\n\n@Injectable()\nexport class JwtInjectorInterceptor implements HttpInterceptor {\n\tprivate readonly jwtConfiguration!: JwtConfiguration;\n\tprivate readonly jwtRefreshConfiguration?: JwtRefreshConfiguration<unknown, unknown>;\n\n\tpublic constructor(\n\t\t@Inject(JWT_CONFIGURATION_TOKEN)\n\t\tjwtConfig: JwtConfiguration,\n\t\t@Inject(DEFAULT_JWT_CONFIGURATION_TOKEN)\n\t\tdefaultJwtConfig: JwtConfiguration,\n\t\t@Optional()\n\t\t@Inject(JWT_REFRESH_CONFIGURATION_TOKEN)\n\t\trefreshConfig?: JwtRefreshConfiguration<unknown, unknown>,\n\t\t@Optional()\n\t\t@Inject(DEFAULT_JWT_REFRESH_CONFIGURATION_TOKEN)\n\t\tdefaultJwtRefreshConfig?: JwtRefreshConfiguration<unknown, unknown>\n\t) {\n\t\tthis.jwtConfiguration = {\n\t\t\t...defaultJwtConfig,\n\t\t\t...jwtConfig,\n\t\t};\n\n\t\tthis.jwtRefreshConfiguration = refreshConfig &&\n\t\t\tdefaultJwtRefreshConfig && {\n\t\t\t\t...defaultJwtRefreshConfig,\n\t\t\t\t...refreshConfig,\n\t\t\t};\n\t}\n\n\tpublic intercept(\n\t\trequest: HttpRequest<unknown>,\n\t\tnext: HttpHandler\n\t): Observable<HttpEvent<unknown>> {\n\t\tconst separatedUrl = separateUrl(request.url);\n\t\treturn intoObservable(this.jwtConfiguration.getToken).pipe(\n\t\t\ttake(1),\n\t\t\tswitchMap((rawToken) => {\n\t\t\t\tif (checkAgainstUrlFilter(this.jwtConfiguration, separatedUrl)) {\n\t\t\t\t\tconst token = rawToken && JwtToken.from(rawToken);\n\t\t\t\t\tconst isAccessTokenExpiredOrInvalid = !token || token.isExpired();\n\t\t\t\t\t// If there is a token to inject\n\t\t\t\t\tif (\n\t\t\t\t\t\trawToken &&\n\t\t\t\t\t\t(!isAccessTokenExpiredOrInvalid || this.jwtRefreshConfiguration)\n\t\t\t\t\t) {\n\t\t\t\t\t\tlet cloned = request.clone({\n\t\t\t\t\t\t\theaders: request.headers.set(\n\t\t\t\t\t\t\t\tthis.jwtConfiguration.header,\n\t\t\t\t\t\t\t\tthis.jwtConfiguration.scheme\n\t\t\t\t\t\t\t\t\t? this.jwtConfiguration.scheme + rawToken\n\t\t\t\t\t\t\t\t\t: rawToken\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t});\n\t\t\t\t\t\tif (this.jwtConfiguration.handleWithCredentials) {\n\t\t\t\t\t\t\tcloned = cloned.clone({\n\t\t\t\t\t\t\t\twithCredentials: true,\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn next.handle(cloned);\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn throwError(\n\t\t\t\t\t\t\tJwtError.createErrorResponse(\n\t\t\t\t\t\t\t\trequest,\n\t\t\t\t\t\t\t\t'Token is expired or invalid, and refresh is not configured.'\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\treturn next.handle(request);\n\t\t\t\t}\n\t\t\t})\n\t\t);\n\t}\n}\n","import {\n\tHttpErrorResponse,\n\tHttpEvent,\n\tHttpHandler,\n\tHttpInterceptor,\n\tHttpRequest,\n} from '@angular/common/http';\nimport { Inject, Injectable } from '@angular/core';\nimport { Observable, throwError } from 'rxjs';\nimport { catchError, filter, switchMap, take, withLatestFrom } from 'rxjs/operators';\nimport { JwtCannotRefreshError, JwtCouldntRefreshError, JwtError } from '../errors/jwt-error.class';\nimport { checkAgainstUrlFilter } from '../function/check-against-url-filter.function';\nimport { intoObservable } from '../function/into-observable.function';\nimport { matchAgainst } from '../function/match-against.function';\nimport { separateUrl } from '../function/separate-url.function';\nimport { tryJwtRefresh } from '../function/try-jwt-refresh.function';\nimport {\n\tJwtConfiguration,\n\tJwtRefreshConfiguration,\n} from '../model/auth-core-configuration.interface';\nimport { JwtToken } from '../model/jwt-token.class';\nimport { JwtRefreshStateService } from '../service/jwt-refresh-state.service';\nimport { JwtTokenService } from '../service/jwt-token.service';\nimport {\n\tDEFAULT_JWT_CONFIGURATION_TOKEN,\n\tDEFAULT_JWT_REFRESH_CONFIGURATION_TOKEN,\n\tJWT_CONFIGURATION_TOKEN,\n\tJWT_REFRESH_CONFIGURATION_TOKEN,\n} from '../token/jwt-configuration.token';\n\n@Injectable()\nexport class JwtRefreshInterceptor implements HttpInterceptor {\n\tprivate readonly jwtConfiguration!: JwtConfiguration;\n\tprivate readonly jwtRefreshConfiguration!: JwtRefreshConfiguration<unknown, unknown>;\n\tprivate readonly rawRefreshToken$: Observable<string | null | undefined>;\n\tprivate readonly isRawRefreshTokenGetterAvailable: boolean;\n\n\tpublic constructor(\n\t\t@Inject(JWT_CONFIGURATION_TOKEN)\n\t\treadonly jwtConfig: JwtConfiguration,\n\t\t@Inject(DEFAULT_JWT_CONFIGURATION_TOKEN)\n\t\treadonly defaultJwtConfig: JwtConfiguration,\n\t\t@Inject(JWT_REFRESH_CONFIGURATION_TOKEN)\n\t\treadonly refreshConfig: JwtRefreshConfiguration<unknown, unknown>,\n\t\t@Inject(DEFAULT_JWT_REFRESH_CONFIGURATION_TOKEN)\n\t\treadonly defaultJwtRefreshConfig: JwtRefreshConfiguration<unknown, unknown>,\n\t\tprivate readonly jwtRefreshStateService: JwtRefreshStateService,\n\t\tprivate readonly jwtTokenService: JwtTokenService\n\t) {\n\t\tthis.jwtConfiguration = {\n\t\t\t...defaultJwtConfig,\n\t\t\t...jwtConfig,\n\t\t};\n\n\t\tthis.jwtRefreshConfiguration = {\n\t\t\t...defaultJwtRefreshConfig,\n\t\t\t...refreshConfig,\n\t\t};\n\n\t\tthis.rawRefreshToken$ = intoObservable(\n\t\t\tthis.jwtRefreshConfiguration.getRefreshToken ?? (() => null)\n\t\t);\n\n\t\tthis.isRawRefreshTokenGetterAvailable = !!this.jwtRefreshConfiguration.getRefreshToken;\n\t}\n\n\tprivate handleWithToken(\n\t\trequest: HttpRequest<unknown>,\n\t\tnext: HttpHandler,\n\t\ttoken: string\n\t): Observable<HttpEvent<unknown>> {\n\t\tconst requestWithUpdatedTokens = request.clone({\n\t\t\theaders: request.headers.set(\n\t\t\t\tthis.jwtConfiguration.header,\n\t\t\t\tthis.jwtConfiguration.scheme + token\n\t\t\t),\n\t\t});\n\t\treturn next.handle(requestWithUpdatedTokens);\n\t}\n\n\tpublic intercept(\n\t\trequest: HttpRequest<unknown>,\n\t\tnext: HttpHandler\n\t): Observable<HttpEvent<unknown>> {\n\t\tconst separatedUrl = separateUrl(request.url);\n\t\tconst jwtHeaderValue = request.headers.get(this.jwtConfiguration.header);\n\n\t\t// Only do something if the request is headed towards a protected endpoint.\n\t\t// The forRoot method of the module ensures that this interceptor is injected\n\t\t// after the token injector interceptor. So by the time this executes, the token should\n\t\t// be here.\n\t\t// And if the url is not the refresh url itself, and any of the other explicitly\n\t\t// filtered urls where refresh is prohibited by config.\n\t\tif (\n\t\t\tjwtHeaderValue &&\n\t\t\t!matchAgainst(request.url)(this.jwtRefreshConfiguration.refreshUrl) &&\n\t\t\tcheckAgainstUrlFilter(this.jwtRefreshConfiguration, separatedUrl)\n\t\t) {\n\t\t\t// If locked, instead of refreshing, wait for it and get the new accessToken\n\t\t\tif (this.jwtRefreshStateService.refreshLock$.value) {\n\t\t\t\t// When the lock unlocks, retry with the new token\n\t\t\t\treturn this.jwtRefreshStateService.refreshLock$.pipe(\n\t\t\t\t\tfilter((lock) => !lock),\n\t\t\t\t\ttake(1),\n\t\t\t\t\twithLatestFrom(this.jwtTokenService.rawAccessToken$),\n\t\t\t\t\tswitchMap(([, accessToken]) => {\n\t\t\t\t\t\t// ...but only if there is actually a token\n\t\t\t\t\t\tif (accessToken) {\n\t\t\t\t\t\t\treturn this.handleWithToken(request, next, accessToken);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn throwError(\n\t\t\t\t\t\t\t\tJwtError.createErrorResponse(\n\t\t\t\t\t\t\t\t\trequest,\n\t\t\t\t\t\t\t\t\t'No access token available after waiting for a refresh'\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t);\n\t\t\t}\n\n\t\t\treturn this.rawRefreshToken$.pipe(\n\t\t\t\ttake(1),\n\t\t\t\tswitchMap((rawRefreshToken) => {\n\t\t\t\t\tconst rawToken = JwtToken.stripScheme(\n\t\t\t\t\t\tjwtHeaderValue,\n\t\t\t\t\t\tthis.jwtConfiguration.scheme\n\t\t\t\t\t);\n\t\t\t\t\tconst token = JwtToken.from(rawToken);\n\t\t\t\t\tconst refreshToken = rawRefreshToken ? JwtToken.from(rawRefreshToken) : null;\n\t\t\t\t\tconst isAccessTokenExpiredOrInvalid = !token || token.isExpired();\n\t\t\t\t\tconst isRefreshTokenExpiredOrInvalid =\n\t\t\t\t\t\t!refreshToken || refreshToken.isExpired();\n\t\t\t\t\t// If we know beforehand that nothing can be done, panic.\n\t\t\t\t\tif (\n\t\t\t\t\t\tisAccessTokenExpiredOrInvalid &&\n\t\t\t\t\t\tthis.isRawRefreshTokenGetterAvailable &&\n\t\t\t\t\t\tisRefreshTokenExpiredOrInvalid\n\t\t\t\t\t) {\n\t\t\t\t\t\treturn throwError(\n\t\t\t\t\t\t\tJwtCannotRefreshError.createErrorResponse(\n\t\t\t\t\t\t\t\trequest,\n\t\t\t\t\t\t\t\t'Both access and refresh tokens are expired'\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\t// If the conversion would fail, that would handle the same as an expired token\n\t\t\t\t\treturn (\n\t\t\t\t\t\tisAccessTokenExpiredOrInvalid\n\t\t\t\t\t\t\t? // If the token is used and is expired, don't even try the request.\n\t\t\t\t\t\t\t  throwError('Expired token, refresh first')\n\t\t\t\t\t\t\t: // If it seems okay, try the request\n\t\t\t\t\t\t\t  next.handle(request)\n\t\t\t\t\t).pipe(\n\t\t\t\t\t\tcatchError((error: HttpErrorResponse | string) =>\n\t\t\t\t\t\t\t// If the request failed, or we failed at the precheck\n\t\t\t\t\t\t\t// Acquire a new token, but only if the error is allowing it\n\t\t\t\t\t\t\t// If a refresh is already happening, wait for it, and use it's results\n\t\t\t\t\t\t\ttryJwtRefresh(\n\t\t\t\t\t\t\t\tnext,\n\t\t\t\t\t\t\t\terror,\n\t\t\t\t\t\t\t\tthis.jwtRefreshConfiguration,\n\t\t\t\t\t\t\t\tthis.jwtRefreshStateService.refreshLock$,\n\t\t\t\t\t\t\t\t(refreshError) =>\n\t\t\t\t\t\t\t\t\tthrowError(\n\t\t\t\t\t\t\t\t\t\tJwtCouldntRefreshError.createErrorResponse(\n\t\t\t\t\t\t\t\t\t\t\trequest,\n\t\t\t\t\t\t\t\t\t\t\trefreshError\n\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\t(refreshResponse) =>\n\t\t\t\t\t\t\t\t\tthis.handleWithToken(request, next, refreshResponse.accessToken)\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t)\n\t\t\t\t\t);\n\t\t\t\t})\n\t\t\t);\n\t\t} else {\n\t\t\treturn next.handle(request);\n\t\t}\n\t}\n}\n","import {\n\tJwtConfigurationProvider,\n\tJwtModuleConfigurationProvider,\n\tJWT_CONFIGURATION_TOKEN,\n} from '../token/jwt-configuration.token';\n\n/**\n * Helps you define a JwtConfigurationProvider\n *\n * @internal\n */\nexport const createJwtConfigurationProvider = (\n\ttokenConfigurationProvider: JwtModuleConfigurationProvider\n): JwtConfigurationProvider =>\n\t({\n\t\tprovide: JWT_CONFIGURATION_TOKEN,\n\t\tmulti: false,\n\t\t...tokenConfigurationProvider,\n\t} as JwtConfigurationProvider);\n","import {\n\tJwtModuleRefreshConfigurationProvider,\n\tJwtRefreshConfigurationProvider,\n\tJWT_REFRESH_CONFIGURATION_TOKEN,\n} from '../token/jwt-configuration.token';\n\n/**\n * Helps you define a JwtConfigurationProvider\n *\n * @internal\n */\nexport const createJwtRefreshConfigurationProvider = <RefreshRequest, RefreshResponse>(\n\ttokenRefreshConfigurationProvider: JwtModuleRefreshConfigurationProvider<\n\t\tRefreshRequest,\n\t\tRefreshResponse\n\t>\n): JwtRefreshConfigurationProvider<RefreshRequest, RefreshResponse> =>\n\t({\n\t\tprovide: JWT_REFRESH_CONFIGURATION_TOKEN,\n\t\tmulti: false,\n\t\t...tokenRefreshConfigurationProvider,\n\t} as JwtRefreshConfigurationProvider<RefreshRequest, RefreshResponse>);\n","import { CommonModule } from '@angular/common';\nimport { HTTP_INTERCEPTORS } from '@angular/common/http';\nimport { ModuleWithProviders, NgModule } from '@angular/core';\nimport { JwtErrorHandlingInterceptor } from './interceptor/jwt-error-handling.interceptor';\nimport { JwtInjectorInterceptor } from './interceptor/jwt-injector.interceptor';\nimport { JwtRefreshInterceptor } from './interceptor/jwt-refresh.interceptor';\nimport {\n\tDEFAULT_JWT_CONFIG,\n\tDEFAULT_JWT_REFRESH_CONFIG,\n} from './model/auth-core-configuration.interface';\nimport { createJwtConfigurationProvider } from './providers/create-jwt-configuration-provider.function';\nimport { createJwtRefreshConfigurationProvider } from './providers/create-jwt-refresh-configuration-provider.function';\nimport {\n\tDEFAULT_JWT_CONFIGURATION_TOKEN,\n\tDEFAULT_JWT_REFRESH_CONFIGURATION_TOKEN,\n\tJwtModuleConfigurationProvider,\n\tJwtModuleRefreshConfigurationProvider,\n} from './token/jwt-configuration.token';\n\n/**\n * This module needs to be configured to use. See the\n * {@link JwtModule#forRoot | forRoot} method for more information.\n *\n * tokens. So that other, plug in configration modules can provide them.\n * Like Ngrx and Local. They then transform their configs into this common one.\n */\n@NgModule({\n\timports: [CommonModule],\n})\nexport class JwtModule {\n\t/**\n\t * To define the interceptors and the token with the provided config.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * (a)NgModule({\n\t *\t\timports: [\n\t *\t\t\tJwtModule.forRoot<Foo>({\n\t *\t\t\t\t\tuseFactory: (foo) => foo.getConf(),\n\t *\t\t\t\t\tdeps: [Foo] // if something has to be injected\n\t *\t\t\t})\n\t *\t\t]\n\t *\t})\n\t *\texport class CoreModule {}\n\t * ```\n\t * @param tokenProvider create with `createAuthTokenProvider` or\n\t * \t`createRefreshableAuthTokenProvider`\n\t */\n\tpublic static forRoot(\n\t\tjwtModuleConfigurationProvider: JwtModuleConfigurationProvider\n\t): ModuleWithProviders<JwtModule>;\n\tpublic static forRoot<RefreshRequest, RefreshResponse>(\n\t\tjwtModuleConfigurationProvider: JwtModuleConfigurationProvider,\n\t\tjwtRefreshConfigurationProvider: JwtModuleRefreshConfigurationProvider<\n\t\t\tRefreshRequest,\n\t\t\tRefreshResponse\n\t\t>\n\t): ModuleWithProviders<JwtModule>;\n\tpublic static forRoot<RefreshRequest, RefreshResponse>(\n\t\tjwtModuleConfigurationProvider: JwtModuleConfigurationProvider,\n\t\tjwtRefreshConfigurationProvider?: JwtModuleRefreshConfigurationProvider<\n\t\t\tRefreshRequest,\n\t\t\tRefreshResponse\n\t\t>\n\t): ModuleWithProviders<JwtModule> {\n\t\treturn {\n\t\t\tngModule: JwtModule,\n\t\t\tproviders: [\n\t\t\t\t{\n\t\t\t\t\tprovide: HTTP_INTERCEPTORS,\n\t\t\t\t\tuseClass: JwtErrorHandlingInterceptor,\n\t\t\t\t\tmulti: true,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tprovide: HTTP_INTERCEPTORS,\n\t\t\t\t\tuseClass: JwtInjectorInterceptor,\n\t\t\t\t\tmulti: true,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tprovide: DEFAULT_JWT_CONFIGURATION_TOKEN,\n\t\t\t\t\tuseValue: DEFAULT_JWT_CONFIG,\n\t\t\t\t},\n\t\t\t\tcreateJwtConfigurationProvider(jwtModuleConfigurationProvider),\n\t\t\t\t...(jwtRefreshConfigurationProvider\n\t\t\t\t\t? [\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tprovide: HTTP_INTERCEPTORS,\n\t\t\t\t\t\t\t\tuseClass: JwtRefreshInterceptor,\n\t\t\t\t\t\t\t\tmulti: true,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tprovide: DEFAULT_JWT_REFRESH_CONFIGURATION_TOKEN,\n\t\t\t\t\t\t\t\tuseValue: DEFAULT_JWT_REFRESH_CONFIG,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tcreateJwtRefreshConfigurationProvider<RefreshRequest, RefreshResponse>(\n\t\t\t\t\t\t\t\tjwtRefreshConfigurationProvider\n\t\t\t\t\t\t\t),\n\t\t\t\t\t  ]\n\t\t\t\t\t: []),\n\t\t\t],\n\t\t};\n\t}\n}\n","// eslint-disable-next-line no-shadow\nexport enum HttpMethod {\n\tGET = 'GET',\n\tHEAD = 'HEAD',\n\tPOST = 'POST',\n\tPUT = 'PUT',\n\tDELETE = 'DELETE',\n\tCONNECT = 'CONNECT',\n\tOPTIONS = 'OPTIONS',\n\tTRACE = 'TRACE',\n\tPATCH = 'PATCH',\n}\n\nexport type HttpMethodType =\n\t| 'GET'\n\t| 'HEAD'\n\t| 'POST'\n\t| 'PUT'\n\t| 'DELETE'\n\t| 'CONNECT'\n\t| 'OPTIONS'\n\t| 'TRACE'\n\t| 'PATCH';\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './index';\n"],"names":["i1.JwtTokenService","i1","i1.JwtRefreshStateService","i2.JwtTokenService"],"mappings":"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"}